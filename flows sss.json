[
    {
        "id": "c6fdc014f79c73d7",
        "type": "tab",
        "label": "radar03",
        "disabled": false,
        "info": ""
    },
    {
        "id": "d3dfdfd513fb0aa2",
        "type": "tab",
        "label": "modbusSolar",
        "disabled": false,
        "info": ""
    },
    {
        "id": "e8bb17e4f6e25a56",
        "type": "tab",
        "label": "pushToLedDisplay",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "f176d52d.8a5d98",
        "type": "tls-config",
        "name": "",
        "cert": "",
        "key": "",
        "ca": "",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "",
        "verifyservercert": true
    },
    {
        "id": "f52ff211.a533d",
        "type": "mqtt-broker",
        "z": "c6fdc014f79c73d7",
        "name": "",
        "broker": "mqtts://broker.react.net.my",
        "port": "1883",
        "tls": "f176d52d.8a5d98",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "7459e1c0f90208e3",
        "type": "serial-port",
        "z": "d3dfdfd513fb0aa2",
        "name": "solar-batery",
        "serialport": "/dev/ttyS0",
        "serialbaud": "9600",
        "databits": "8",
        "parity": "none",
        "stopbits": "1",
        "waitfor": "",
        "dtr": "none",
        "rts": "none",
        "cts": "none",
        "dsr": "none",
        "newline": "200",
        "bin": "bin",
        "out": "time",
        "addchar": "",
        "responsetimeout": "10000"
    },
    {
        "id": "499334b129b933ed",
        "type": "serial-port",
        "z": "e8bb17e4f6e25a56",
        "name": "",
        "serialport": "/dev/ttyS3",
        "serialbaud": "9600",
        "databits": 8,
        "parity": "none",
        "stopbits": 1,
        "waitfor": "",
        "dtr": "none",
        "rts": "none",
        "cts": "none",
        "dsr": "none",
        "newline": "\\n",
        "bin": "bin",
        "out": "char",
        "addchar": "",
        "responsetimeout": 10000
    },
    {
        "id": "57ac84494075ccc8",
        "type": "serial-port",
        "z": "d3dfdfd513fb0aa2",
        "name": "",
        "serialport": "/dev/ttyS0",
        "serialbaud": "9600",
        "databits": 8,
        "parity": "none",
        "stopbits": 1,
        "waitfor": "",
        "dtr": "none",
        "rts": "none",
        "cts": "none",
        "dsr": "none",
        "newline": "\\n",
        "bin": "bin",
        "out": "char",
        "addchar": "",
        "responsetimeout": 10000
    },
    {
        "id": "951f201ab53ccfb0",
        "type": "serial-port",
        "z": "d3dfdfd513fb0aa2",
        "name": "",
        "serialport": "/dev/ttyS0",
        "serialbaud": "9600",
        "databits": 8,
        "parity": "none",
        "stopbits": 1,
        "waitfor": "",
        "dtr": "none",
        "rts": "none",
        "cts": "none",
        "dsr": "none",
        "newline": "\\n",
        "bin": "bin",
        "out": "char",
        "addchar": "",
        "responsetimeout": 10000
    },
    {
        "id": "db51e67223e51d73",
        "type": "mqtt-broker",
        "name": "",
        "broker": "mqtts://broker.react.net.my",
        "port": 1883,
        "tls": "f176d52d.8a5d98",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "394275e31b267799",
        "type": "mqtt-broker",
        "name": "react 2",
        "broker": "broker.react.net.my",
        "port": "8883",
        "tls": "f176d52d.8a5d98",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "2054b162aec9c313",
        "type": "mqtt-broker",
        "name": "",
        "broker": "broker.react.net.my",
        "port": "8883",
        "tls": "f176d52d.8a5d98",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "c00a95d04f85d204",
        "type": "mqtt out",
        "z": "c6fdc014f79c73d7",
        "name": "new broker",
        "topic": "/data/traffic/radar03/",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "f52ff211.a533d",
        "x": 830,
        "y": 120,
        "wires": []
    },
    {
        "id": "5c387bf597313272",
        "type": "tcp in",
        "z": "c6fdc014f79c73d7",
        "name": "",
        "server": "client",
        "host": "192.168.12.11",
        "port": "8998",
        "datamode": "stream",
        "datatype": "buffer",
        "newline": "",
        "topic": "",
        "trim": false,
        "base64": false,
        "tls": "",
        "x": 240,
        "y": 220,
        "wires": [
            [
                "6af15a9e987a0b63"
            ]
        ]
    },
    {
        "id": "2924467d7f1b989c",
        "type": "comment",
        "z": "c6fdc014f79c73d7",
        "name": "",
        "info": "Couting accurately.",
        "x": 300,
        "y": 60,
        "wires": []
    },
    {
        "id": "6af15a9e987a0b63",
        "type": "function",
        "z": "c6fdc014f79c73d7",
        "name": "Counting and Classification",
        "func": "const HEADER = Buffer.from([0x55, 0xAA, 0x55, 0xBB]);\nconst FOOTER = Buffer.from([0x55, 0xCC, 0x55, 0xDD]);\nconst packet = Buffer.from(msg.payload, 'hex'); // Convert HEX string to Buffer\n\nconst TARGET_TYPES = {\n    0x01: \"C6\", 0x02: \"C6\", 0x03: \"C6\", 0x04: \"C5\",\n    0x05: \"C2\", 0x06: \"C1\", 0x07: \"C1\", 0x08: \"C4\",\n    0x09: \"C3\", 0x0A: \"C3\", 0x0C: \"C4\", 0x0E: \"C2\"\n};\n\nif (!packet.subarray(0, HEADER.length).equals(HEADER) ||\n    !packet.subarray(packet.length - FOOTER.length).equals(FOOTER)) {\n    node.warn(\"Invalid packet: Missing HEADER or FOOTER\");\n    return null;\n}\n\nconst typeByte = packet[HEADER.length];\nif (typeByte !== 0x05) return null;\n\nconst checksum = packet[5];\nconst deviceIDBuffer = packet.subarray(8, 28);\nconst deviceID = deviceIDBuffer.toString('hex');\n\nconst timestampMs = packet.readBigUInt64BE(28);\nconst malaysiaOffset = 8 * 60 * 60 * 1000;\nconst timestampDate = new Date(Number(timestampMs) + malaysiaOffset);\nconst formattedTimestamp = timestampDate.toISOString();\n\nconst numEntries = packet.readUInt16BE(36);\nlet offset = 38;\nconst PASS_DATA_SIZE = 23;\nlet passData = [];\n\nfor (let i = 0; i < numEntries; i++) {\n    if (packet.length < offset + PASS_DATA_SIZE) break;\n    const entryData = packet.subarray(offset, offset + PASS_DATA_SIZE);\n\n    // Check occupancy status at byte index 18.\n    // If not \"Entering\" (i.e. value 1), ignore this target.\n    const occupancyStatus = entryData.readUInt8(18);\n    if (occupancyStatus !== 1) {\n        offset += PASS_DATA_SIZE;\n        continue;\n    }\n\n    const laneNumber = entryData.readUInt16BE(0);\n    const vehicleSpeed = (entryData.readUInt16BE(4) / 10.0);\n    const targetTypeRaw = entryData.readUInt8(19);\n    const targetType = TARGET_TYPES[targetTypeRaw] || \"other\";\n\n    passData.push({\n        lane: laneNumber,\n        class: targetType,\n        speed: vehicleSpeed\n    });\n    offset += PASS_DATA_SIZE;\n}\n\n// If no targets meet the \"Entering\" criteria, completely ignore the packet.\nif (passData.length === 0) {\n    return null;\n}\n\nmsg.payload = {\n    header: {\n        frameType: typeByte,\n        checksum: checksum,\n        deviceId: deviceID,\n        timestamp: formattedTimestamp,\n        numberOfTargets: passData.length\n    },\n    target: passData[0]\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 460,
        "y": 140,
        "wires": [
            [
                "c00a95d04f85d204",
                "6af2a7d381f9eaf0"
            ]
        ]
    },
    {
        "id": "6af2a7d381f9eaf0",
        "type": "debug",
        "z": "c6fdc014f79c73d7",
        "name": "debug 12",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 620,
        "y": 260,
        "wires": []
    },
    {
        "id": "ba3f955836dd6411",
        "type": "function",
        "z": "d3dfdfd513fb0aa2",
        "name": "decode data",
        "func": "// Input buffer\nlet buffer = msg.payload; // Assuming msg.payload contains the buffer data\n\nbuffer = buffer.slice(0,72);\n// Decode registers directly into msg.payload\nmsg.payload = {\n    alarmStatus: (buffer[15] << 8) | buffer[16], // 16-bit value\n    remainingAh: ((buffer[17] << 8) | buffer[18]) / 10, // 16-bit value, scaled by 10\n    remainingSoC: buffer[19], // 8-bit value\n    humidity: buffer[20], // 8-bit value\n    batteryPower: ((buffer[21] << 8) | buffer[22]) / 10, // 16-bit value, scaled by 10\n    totalBatteryVoltage: ((buffer[23] << 8) | buffer[24]) / 10, // 16-bit value, scaled by 10\n    // totalBatteryCurrent: ((buffer[25] << 8) | buffer[26]) / 10, // 16-bit value, scaled by 10\n    batteryChargingCurrent: ((buffer[27] << 8) | buffer[28]) / 100, // 16-bit value, scaled by 100\n    batteryDischargingCurrent: ((buffer[29] << 8) | buffer[30]) / 100, // 16-bit value, scaled by 100\n    Temp1: buffer[31], // 8-bit value\n    Temp2: buffer[32], // 8-bit value\n   // clampingVoltage: ((buffer[47] << 8) | buffer[48]) / 10 // 16-bit value, scaled by 10\n    // Uncomment the lines below if needed:\n    // internalTimestamp: ((buffer[49] << 8) | buffer[50]), // 16-bit value\n    // remainingNumberOfDays: ((buffer[52] << 8) | buffer[53]) / 100 // 16-bit value, scaled by 100\n};\n\n// Return the decoded data\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 80,
        "wires": [
            [
                "0f9698fea83a10c4"
            ]
        ]
    },
    {
        "id": "0f9698fea83a10c4",
        "type": "debug",
        "z": "d3dfdfd513fb0aa2",
        "name": "",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 890,
        "y": 80,
        "wires": []
    },
    {
        "id": "02420378b682d2a9",
        "type": "debug",
        "z": "d3dfdfd513fb0aa2",
        "name": "",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 530,
        "y": 60,
        "wires": []
    },
    {
        "id": "5f7aa11225841d0b",
        "type": "mqtt out",
        "z": "d3dfdfd513fb0aa2",
        "name": "",
        "topic": "smart/solar/0000000000000001",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "db51e67223e51d73",
        "x": 1190,
        "y": 320,
        "wires": []
    },
    {
        "id": "7708ede44e016d0a",
        "type": "function",
        "z": "d3dfdfd513fb0aa2",
        "name": "",
        "func": "// Input buffer\nlet buffer = msg.payload; // Assuming msg.payload contains the buffer data\n\n// Check if buffer has at least 55 elements (buffer[54] exists)\nif (buffer && buffer.length > 53) {\n    // Decode the buffer into the desired JSON format\n    msg.payload = {\n        deveui: \"0000000000000001\",\n        ipAdress: \"http://192.168.12.1\", // Static value, replace as needed\n        devicename: \"elastel\",  // Static value, replace as needed\n        timestamp: Date.now(), // Current timestamp in milliseconds\n        alarmInformation: (buffer[15] << 8) | buffer[16], // 16-bit value\n        batteryChargingCurrent: ((buffer[27] << 8) | buffer[28]) / 100, // 16-bit value, scaled by 100\n        batteryDischargeCurrent: ((buffer[29] << 8) | buffer[30]) / 100, // 16-bit value, scaled by 100\n        batteryPower: ((buffer[21] << 8) | buffer[22]), // 16-bit value, scaled by 10\n        batterySoC: buffer[19], // 8-bit value\n        clampingVoltage: ((buffer[47] << 8) | buffer[48]) / 10, // 16-bit value, scaled by 10\n        controlInformation: (buffer[11] << 8) | buffer[12], // Example static value, replace if dynamic\n        internalTimestampHigh: ((buffer[49] << 8) | buffer[50]), // 16-bit value\n        internalTimestampLow: ((buffer[51] << 8) | buffer[52]), // 16-bit value\n        remainingAH: ((buffer[17] << 8) | buffer[18]) / 10, // 16-bit value, scaled by 10\n        remainingDays: ((buffer[52] << 8) | buffer[53]) / 100, // 16-bit value, scaled by 100\n        temperatures1: buffer[31], // 8-bit value\n        temperatures2: buffer[32], // 8-bit value\n        totalBatteryCurrent: ((buffer[25] << 8) | buffer[26]) / 10, // 16-bit value, scaled by 10\n        totalBatteryVoltage: ((buffer[23] << 8) | buffer[24]) / 10, // 16-bit value, scaled by 10\n        humidity: buffer[20]\n    };\n} else {\n    // If buffer[54] doesn't exist, return an empty message or a warning\n    msg.payload = { error: \"Buffer length is insufficient\" };\n}\n\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 740,
        "y": 180,
        "wires": [
            [
                "a01ae8ea72715992"
            ]
        ]
    },
    {
        "id": "a01ae8ea72715992",
        "type": "debug",
        "z": "d3dfdfd513fb0aa2",
        "name": "",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 970,
        "y": 200,
        "wires": []
    },
    {
        "id": "ff4e245b16e85dab",
        "type": "function",
        "z": "d3dfdfd513fb0aa2",
        "name": "",
        "func": "\n// Input buffer\nlet buffer = msg.payload; // Assuming msg.payload contains the buffer data\n\n// Convert buffer to an array of hex values\nlet hexArray = Array.from(buffer, byte => byte.toString(16).padStart(2, '0'));\n\n// Construct the output\nmsg.payload = {\n    // originalBuffer: buffer,\n    hexRepresentation: hexArray.join(\" \") // Combine hex values into a single string\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 180,
        "wires": [
            [
                "b2faa1afe512a80c",
                "8a9d785e6a5edac1",
                "5cfb238b3a200525"
            ]
        ]
    },
    {
        "id": "b2faa1afe512a80c",
        "type": "debug",
        "z": "d3dfdfd513fb0aa2",
        "name": "",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 730,
        "y": 220,
        "wires": []
    },
    {
        "id": "e563708f3023885b",
        "type": "function",
        "z": "d3dfdfd513fb0aa2",
        "name": "Full-Decode-based-docs",
        "func": "let buffer = msg.payload;\n\nbuffer = buffer.slice(11, 62)\n\nfunction toHex(num) {\n    return \"0x\" + num.toString(16).padStart(2, '0').toUpperCase();\n}\n\n// Protocol fields remain in hex\nlet startFlag = toHex(buffer[0]);\nlet headerInfo = toHex(buffer[1]);\nlet controlInfo = toHex(buffer[2]);\nlet messageLength = toHex(buffer[3]);\nlet fragmentOffset = toHex((buffer[4] << 8) | buffer[5]);\nlet commandData = toHex(buffer[6]);\nlet commandBytes = [toHex(buffer[7]), toHex(buffer[8]), toHex(buffer[9])];\nlet errorCode = toHex(buffer[10]);\nlet functionCode = toHex(buffer[11]);\nlet startAddress = toHex((buffer[12] << 8) | buffer[13]);\nlet registerCount = toHex(buffer[14]);\n\n// Battery data all in decimal\nlet alarmInformation = (buffer[15] << 8) | buffer[16];\nlet remainingAH = ((buffer[17] << 8) | buffer[18]) / 10;\nlet batterySoC = buffer[19];\nlet humidity = buffer[20];\nlet batteryPower = (buffer[21] << 8) | buffer[22];\nlet totalBatteryVoltage = ((buffer[23] << 8) | buffer[24]) / 10;\nlet totalBatteryCurrent = ((buffer[25] << 8) | buffer[26]) / 10;\nlet batteryChargingCurrent = ((buffer[27] << 8) | buffer[28]) / 100;\nlet batteryDischargeCurrent = ((buffer[29] << 8) | buffer[30]) / 100;\n\n// Temperature readings - convert to decimal except \"Not installed\"\nlet temperatures = [];\nfor (let i = 0; i < 8; i++) {\n    let temp1 = buffer[31 + i * 2];\n    let temp2 = buffer[32 + i * 2];\n    temperatures.push({\n        temp1: temp1 === 0xCE ? \"Not installed\" : temp1,\n        temp2: temp2 === 0xCE ? \"Not installed\" : temp2\n    });\n}\n\n// CRC and end flag remain in hex\nlet crc = toHex((buffer[buffer.length - 3] << 8) | buffer[buffer.length - 2]);\nlet endFlag = toHex(buffer[buffer.length - 1]);\n\nmsg.payload = {\n    protocol: {\n        startFlag: startFlag,\n        headerInfo: headerInfo,\n        controlInfo: controlInfo,\n        messageLength: messageLength,\n        fragmentOffset: fragmentOffset,\n        commandData: commandData,\n        commandBytes: commandBytes,\n        errorCode: errorCode,\n        functionCode: functionCode,\n        startAddress: startAddress,\n        registerCount: registerCount\n    },\n    batteryData: {\n        alarmInformation: alarmInformation,\n        remainingAH: remainingAH,\n        batterySoC: batterySoC,\n        humidity: humidity,\n        batteryPower: batteryPower,\n        totalBatteryVoltage: totalBatteryVoltage,\n        totalBatteryCurrent: totalBatteryCurrent,\n        batteryChargingCurrent: batteryChargingCurrent,\n        batteryDischargeCurrent: batteryDischargeCurrent,\n        temperatures: temperatures\n    },\n    verification: {\n        crc: crc,\n        endFlag: endFlag\n    }\n};\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 290,
        "y": 300,
        "wires": [
            [
                "eec3995c4100cde7"
            ]
        ]
    },
    {
        "id": "f69ef20e49fd5e67",
        "type": "function",
        "z": "d3dfdfd513fb0aa2",
        "name": "Read-Command",
        "func": "// Define the command to request 22 registers starting from 0x200\n// let commandHex = \"41160F0100009D0A0B0B04020016211A2B\";\nlet commandHex = \"41160F0100003A0A0B0B0402021221B92B\"\n\n// Convert the hex string to a Buffer object\nmsg.payload = Buffer.from(commandHex, 'hex');\n\n// Send the command to the serial out node\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 300,
        "y": 680,
        "wires": [
            [
                "0870edf5488db2a6"
            ]
        ]
    },
    {
        "id": "ae3ca7f3c39fa801",
        "type": "inject",
        "z": "d3dfdfd513fb0aa2",
        "name": "",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "*/10 0-23 * * *",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "str",
        "x": 210,
        "y": 540,
        "wires": [
            [
                "f69ef20e49fd5e67"
            ]
        ]
    },
    {
        "id": "eec3995c4100cde7",
        "type": "debug",
        "z": "d3dfdfd513fb0aa2",
        "name": "debug 9",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 460,
        "y": 400,
        "wires": []
    },
    {
        "id": "80565d49ed58925c",
        "type": "function",
        "z": "d3dfdfd513fb0aa2",
        "name": "batteryData Decode",
        "func": "let buffer = msg.payload;\n\nbuffer = buffer.slice(0,61);\n// Function to convert numbers to hex format\nfunction toHex(num) {\n    return \"0x\" + num.toString(16).padStart(2, '0').toUpperCase();\n}\n\n// Convert 16-bit value to signed int16 using two's complement\nfunction toInt16(highByte, lowByte) {\n    let value = (highByte << 8) | lowByte;\n    return value > 0x7FFF ? value - 0x10000 : value;\n}\n\n// // Check if buffer length matches expected size\n// if (buffer.length !== 63) {\n//     node.warn(\"Buffer length is not 54. Passing message without decoding.\");\n//     return msg; // Pass through without changes\n// }\n\n// Decode protocol fields\nlet startFlag = toHex(buffer[0]);\nlet headerInfo = toHex(buffer[1]);\nlet controlInfo = toHex(buffer[2]);\nlet messageLength = toHex(buffer[3]);\nlet fragmentOffset = toHex((buffer[4] << 8) | buffer[5]);\nlet commandData = toHex(buffer[6]);\nlet commandBytes = [toHex(buffer[7]), toHex(buffer[8]), toHex(buffer[9])];\nlet errorCode = toHex(buffer[10]);\nlet functionCode = toHex(buffer[11]);\nlet startAddress = toHex((buffer[12] << 8) | buffer[13]);\nlet registerCount = toHex(buffer[14]);\n\n// Battery data\nlet alarmInformation = (buffer[15] << 8) | buffer[16];\nlet remainingAH = ((buffer[17] << 8) | buffer[18]) / 10;\nlet batterySoC = buffer[19];\nlet humidity = buffer[20];\nlet batteryPower = toInt16(buffer[21], buffer[22]);\nlet totalBatteryVoltage = ((buffer[23] << 8) | buffer[24]) / 10;\n// Convert currents to signed values\nlet totalBatteryCurrent = toInt16(buffer[25], buffer[26]) / 10;\nlet batteryChargingCurrent = toInt16(buffer[27], buffer[28]) / 100;\nlet batteryDischargeCurrent = toInt16(buffer[29], buffer[30]) / 100;\n\n// Extract first temperature pair\nlet temp1 = buffer[31] === 0xCE ? \"Not installed\" : buffer[31];\nlet temp2 = buffer[32] === 0xCE ? \"Not installed\" : buffer[32];\n\n// CRC and end flag remain in hex\nlet crc = toHex((buffer[buffer.length - 3] << 8) | buffer[buffer.length - 2]);\nlet endFlag = toHex(buffer[buffer.length - 1]);\n\n// Calculate net discharge current\nlet netDischargeCurrent = batteryDischargeCurrent - batteryChargingCurrent; // Net discharge current in A\n\n// Check if net discharge current is positive (battery is discharging)\nif (netDischargeCurrent > 0) {\n    // Calculate remaining hours and days based on real-time values\n    let remainingHours = remainingAH / netDischargeCurrent; // Remaining hours\n    let remainingDays = remainingHours / 24; // Remaining days\n\n    // Add calculated values to payload\n    msg.payload = {\n        batteryData: {\n            deveui: \"0000000000000001\",\n            ipAdress: \"http://192.168.12.254\",\n            devicename: \"elastel\",\n            alarmInformation: alarmInformation,\n            remainingAH: remainingAH,\n            batterySoC: batterySoC,\n            // humidity: humidity,\n            batteryPower: batteryPower,\n            totalBatteryVoltage: totalBatteryVoltage,\n            totalBatteryCurrent: totalBatteryCurrent,\n            batteryChargingCurrent: batteryChargingCurrent,\n            batteryDischargeCurrent: batteryDischargeCurrent,\n            temperatures1: temp1,\n            temperatures2: temp2,\n            remainingHours: remainingHours.toFixed(2), // Rounded to 2 decimal places\n            remainingDays: remainingDays.toFixed(2)  // Rounded to 2 decimal places\n        }\n    };\n} else {\n    // If the net discharge current is 0 or negative (charging or no load), display \"N/A\"\n    node.warn(\"Net discharge current is zero or negative, unable to calculate remaining life.\");\n    msg.payload = {\n        batteryData: {\n            deveui: \"0000000000000001\",\n            ipAdress: \"http://192.168.12.254\",\n            devicename: \"elastel\",\n            alarmInformation: alarmInformation,\n            remainingAH: remainingAH,\n            batterySoC: batterySoC,\n            // humidity: humidity,\n            batteryPower: batteryPower,\n            totalBatteryVoltage: totalBatteryVoltage,\n            totalBatteryCurrent: totalBatteryCurrent,\n            batteryChargingCurrent: batteryChargingCurrent,\n            batteryDischargeCurrent: batteryDischargeCurrent,\n            temperatures1: temp1,\n            temperatures2: temp2,\n            remainingHours: \"N/A\",\n            remainingDays: \"N/A\"\n        }\n    };\n}\n\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 740,
        "y": 320,
        "wires": [
            [
                "1be0298cc11e5371"
            ]
        ]
    },
    {
        "id": "1be0298cc11e5371",
        "type": "debug",
        "z": "d3dfdfd513fb0aa2",
        "name": "debug 10",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 280,
        "wires": []
    },
    {
        "id": "50a1a20f3e3a035f",
        "type": "debug",
        "z": "d3dfdfd513fb0aa2",
        "name": "debug 13",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 700,
        "y": 540,
        "wires": []
    },
    {
        "id": "4e3d7ac33429ccbe",
        "type": "debug",
        "z": "d3dfdfd513fb0aa2",
        "name": "debug 14",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 920,
        "y": 420,
        "wires": []
    },
    {
        "id": "f0f34b43162e28ff",
        "type": "function",
        "z": "d3dfdfd513fb0aa2",
        "name": "function 1",
        "func": "var x = msg.payload;\nmsg.payload = x.slice(11, 62)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 200,
        "y": 440,
        "wires": [
            [
                "9efa28ef98cd5407"
            ]
        ]
    },
    {
        "id": "9efa28ef98cd5407",
        "type": "debug",
        "z": "d3dfdfd513fb0aa2",
        "name": "debug 15",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 480,
        "y": 460,
        "wires": []
    },
    {
        "id": "5cfb238b3a200525",
        "type": "function",
        "z": "d3dfdfd513fb0aa2",
        "name": "function 2",
        "func": "function decodeData(msg) {\n    const hexData = msg.payload.hexRepresentation.replace(/ /g, '');\n    const dataStart = 30;\n    const data = hexData.substring(dataStart);\n\n    function hexToDec(hex) {\n        if (!hex) return 0;\n        return parseInt(hex, 16);\n    }\n\n    // Function to convert hex to signed int8\n    function hexToSignedInt8(hex) {\n        let value = parseInt(hex, 16);\n        // Convert to signed 8-bit\n        if (value > 127) {\n            value = value - 256;\n        }\n        return value;\n    }\n\n    try {\n        // Decode temperatures (2*sint8 format)\n        // 0x020A is temp1/temp2\n        const temp1 = hexToSignedInt8(data.substring(32, 34)); // First byte\n        const temp2 = hexToSignedInt8(data.substring(34, 36)); // Second byte\n\n        // First decode all values\n        const remainingAh = (hexToDec(data.substring(4, 8)) / 10);\n        const dischargeCurrent = (hexToDec(data.substring(28, 32)) / 100);\n        const chargingCurrent = (hexToDec(data.substring(24, 28)) / 100);\n\n        // Calculate net discharge current\n        const netDischargeCurrent = parseFloat(dischargeCurrent) - parseFloat(chargingCurrent);\n\n        // Initialize remaining time values\n        let remainingHours = \"N/A\";\n        let remainingDays = 0;\n\n        // Calculate remaining time if discharging\n        if (netDischargeCurrent > 0) {\n            remainingHours = (parseFloat(remainingAh) / netDischargeCurrent).toFixed(2);\n            remainingDays = (parseFloat(remainingHours) / 24).toFixed(2);\n        }\n\n        // Create payload\n        msg.payload = {\n            deveui: \"0000000000000001\",\n            ipAdress: \"http://192.168.12.1\",\n            devicename: \"bivocom\",\n            alarm: hexToDec(data.substring(0, 4)),\n            remainingAh: remainingAh,\n            batterySoc: hexToDec(data.substring(8, 10)),\n            humidity: hexToDec(data.substring(10, 12)),\n            batteryPower: hexToDec(data.substring(12, 16)),\n            totalBatteryVoltage: (hexToDec(data.substring(16, 20)) / 10),\n            totalBatteryCurrent: ((hexToDec(data.substring(20, 24)) << 16 >> 16) / 10),\n            batteryChargingCurrent: chargingCurrent,\n            batteryDischargeCurrent: dischargeCurrent,\n            temperatures1: temp1,\n            temperatures2: temp2,\n            remainingHours: remainingHours,\n            remainingDays: remainingDays\n        };\n\n        return msg;\n\n    } catch (error) {\n        node.error(\"Error decoding data: \" + error.message);\n        return null;\n    }\n}\n\nreturn decodeData(msg);",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 700,
        "y": 400,
        "wires": [
            [
                "4e3d7ac33429ccbe",
                "5f7aa11225841d0b"
            ]
        ]
    },
    {
        "id": "8a9d785e6a5edac1",
        "type": "function",
        "z": "d3dfdfd513fb0aa2",
        "name": "function 3",
        "func": "function decodeData(msg) {\n    const hexData = msg.payload.hexRepresentation.replace(/ /g, '');\n    const dataStart = 30;\n    const data = hexData.substring(dataStart);\n\n    function hexToDec(hex) {\n        if (!hex) return 0;\n        return parseInt(hex, 16);\n    }\n\n    // Function to convert hex to signed int8\n    function hexToSignedInt8(hex) {\n        let value = parseInt(hex, 16);\n        // Convert to signed 8-bit\n        if (value > 127) {\n            value = value - 256;\n        }\n        return value;\n    }\n\n    try {\n        // Decode temperatures (2*sint8 format)\n        // 0x020A is temp1/temp2\n        const temp1 = hexToSignedInt8(data.substring(32, 34)); // First byte\n        const temp2 = hexToSignedInt8(data.substring(34, 36)); // Second byte\n\n        // First decode all values\n        const remainingAh = (hexToDec(data.substring(4, 8)) / 10).toFixed(1);\n        const dischargeCurrent = (hexToDec(data.substring(28, 32)) / 100).toFixed(2);\n        const chargingCurrent = (hexToDec(data.substring(24, 28)) / 100).toFixed(2);\n\n        // Calculate net discharge current\n        const netDischargeCurrent = parseFloat(dischargeCurrent) - parseFloat(chargingCurrent);\n\n        // Initialize remaining time values\n        let remainingHours = \"N/A\";\n        let remainingDays = \"N/A\";\n\n        // Calculate remaining time if discharging\n        if (netDischargeCurrent > 0) {\n            remainingHours = (parseFloat(remainingAh) / netDischargeCurrent).toFixed(2);\n            remainingDays = (parseFloat(remainingHours) / 24).toFixed(2);\n        }\n\n        // Create payload\n        msg.payload = {\n            deveui: \"0000000000000001\",\n            ipAdress: \"http://192.168.12.254\",\n            devicename: \"elastel\",\n            alarm: hexToDec(data.substring(0, 4)),\n            remainingAh: remainingAh,\n            batterySoc: hexToDec(data.substring(8, 10)),\n            humidity: hexToDec(data.substring(10, 12)),\n            power: hexToDec(data.substring(12, 16)),\n            voltage: (hexToDec(data.substring(16, 20)) / 10).toFixed(1),\n            totalCurrent: ((hexToDec(data.substring(20, 24)) << 16 >> 16) / 10).toFixed(1),\n            chargingCurrent: chargingCurrent,\n            dischargeCurrent: dischargeCurrent,\n            temperatures1: temp1,\n            temperatures2: temp2,\n            remainingHours: remainingHours,\n            remainingDays: remainingDays\n        };\n\n        return msg;\n\n    } catch (error) {\n        node.error(\"Error decoding data: \" + error.message);\n        return null;\n    }\n}\n\nreturn decodeData(msg);",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 460,
        "wires": [
            [
                "81f3c0c393123c1a"
            ]
        ]
    },
    {
        "id": "81f3c0c393123c1a",
        "type": "debug",
        "z": "d3dfdfd513fb0aa2",
        "name": "debug 16",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 860,
        "y": 480,
        "wires": []
    },
    {
        "id": "49e26240e82539d0",
        "type": "serial in",
        "z": "d3dfdfd513fb0aa2",
        "name": "",
        "serial": "7459e1c0f90208e3",
        "x": 170,
        "y": 180,
        "wires": [
            [
                "02420378b682d2a9",
                "ff4e245b16e85dab",
                "ba3f955836dd6411",
                "f0f34b43162e28ff",
                "9efa28ef98cd5407"
            ]
        ]
    },
    {
        "id": "0870edf5488db2a6",
        "type": "serial out",
        "z": "d3dfdfd513fb0aa2",
        "name": "command request",
        "serial": "7459e1c0f90208e3",
        "x": 550,
        "y": 680,
        "wires": []
    },
    {
        "id": "9e6d1b1ffdff3777",
        "type": "function",
        "z": "e8bb17e4f6e25a56",
        "name": "sniff from 00x05",
        "func": "const HEADER = Buffer.from([0x55, 0xAA, 0x55, 0xBB]);\nconst packet = Buffer.from(msg.payload);\nconst typeByte = packet[HEADER.length];\n\nif (typeByte === 0x05) {\n   msg.payload = packet.toString('hex').toUpperCase();\n   msg.payload = packet;\n   if(msg.payload.length === 64){\n    // let speed = hexString.readUInt16BE(42) / 10;\n    // let speeds = parseInt(speed);\n    //         //  msg.payload = speed / 10;\n    //         // Only send the speed if it's 20 or above\n    //     if (speeds > 20) {\n    //         let numStr = speeds.toString();\n    //             // Convert each digit to its ASCII value (in hex)\n    //         let hexDigits = numStr.split('').map(digit => digit.charCodeAt(0).toString(16).toUpperCase());\n\n    //             // Combine into a buffer if needed\n    //         msg.payload = Buffer.from(hexDigits.map(d => parseInt(d, 16)));\n    //             //msg.payload = parseInt(speed);\n    //         }       \n    return msg;   \n   }\n   \n}\n//return null;\n\n// && packet.length == 128",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 200,
        "y": 280,
        "wires": [
            [
                "d28347799e7e47c1",
                "18f04cb4c55de653",
                "600b684b44c4f626"
            ]
        ]
    },
    {
        "id": "d28347799e7e47c1",
        "type": "function",
        "z": "e8bb17e4f6e25a56",
        "name": "decode data",
        "func": "// Check if payload exists and is valid\nif (msg.payload) {\n    let hexString = msg.payload;\n\n    if (typeof hexString === \"string\" && hexString.length >= 76) {\n        try {\n            // Extract first target data section (starting at byte 39)\n            let target1 = {\n                // Target ID (10 bytes)\n                targetId: hexString.substring(76, 96),\n                \n                // Target Lane (1 byte)\n                lane: parseInt(hexString.substring(96, 98), 16),\n                \n                // Target Type (1 byte)\n                type: parseInt(hexString.substring(98, 100), 16),\n                \n                // Color (1 byte)\n                color: parseInt(hexString.substring(100, 102), 16),\n                \n                // Skip plate number (12 bytes of zeros)\n                \n                // X Coordinate (2 bytes) - might be negative\n                xCoord: (parseInt(hexString.substring(126, 130), 16) << 16 >> 16) / 10,\n                \n                // Y Coordinate (2 bytes)\n                yCoord: parseInt(hexString.substring(130, 134), 16) / 10,\n                \n                // Speed (2 bytes)\n                speed: (parseInt(hexString.substring(134, 138), 16) / 10) * 3.6,\n                \n                // Image X axis (2 bytes)\n                imageX: parseInt(hexString.substring(138, 142), 16),\n                \n                // Image Y axis (2 bytes)\n                imageY: parseInt(hexString.substring(142, 146), 16),\n                \n                // Target Azimuth Angle (2 bytes)\n                azimuth: parseInt(hexString.substring(154, 158), 16) / 10,\n                \n                // Vehicle dimensions (1 byte each)\n                length: parseInt(hexString.substring(158, 160), 16) / 10,\n                width: parseInt(hexString.substring(160, 162), 16) / 10,\n                height: parseInt(hexString.substring(162, 164), 16) / 10,\n                \n                // Parking status (1 byte)\n                parkingStatus: parseInt(hexString.substring(164, 166), 16),\n                \n                // Direction speeds (2 bytes each)\n                xSpeed: (parseInt(hexString.substring(166, 170), 16) << 16 >> 16) / 10,\n                ySpeed: (parseInt(hexString.substring(170, 174), 16) << 16 >> 16) / 10,\n                \n                // Acceleration values (2 bytes each)\n                motionAccel: (parseInt(hexString.substring(174, 178), 16) << 16 >> 16) / 100,\n                xAccel: (parseInt(hexString.substring(178, 182), 16) << 16 >> 16) / 100,\n                yAccel: (parseInt(hexString.substring(182, 186), 16) << 16 >> 16) / 100,\n                \n                // Location (4 bytes each)\n                longitude: parseInt(hexString.substring(186, 194), 16) / 10000000,\n                latitude: parseInt(hexString.substring(194, 202), 16) / 10000000\n            };\n\n            // Add type description\n            switch(target1.type) {\n                case 0: target1.typeDesc = \"other\"; break;\n                case 1: target1.typeDesc = \"C6\"; break;\n                case 2: target1.typeDesc = \"C6\"; break;\n                case 3: target1.typeDesc = \"tricycle\"; break;\n                case 4: target1.typeDesc = \"C5\"; break;\n                case 5: target1.typeDesc = \"C3\"; break;\n                case 6: target1.typeDesc = \"C1\"; break;\n                case 7: target1.typeDesc = \"C2\"; break;\n                case 8: target1.typeDesc = \"C4\"; break;\n                case 9: target1.typeDesc = \"C4\"; break;\n                case 10: target1.typeDesc = \"C3\"; break;\n                case 11: target1.typeDesc = \"C4\"; break;\n                case 12: target1.typeDesc = \"C4\"; break;\n                case 13: target1.typeDesc = \"person\"; break;\n                case 14: target1.typeDesc = \"c5\"; break;\n                default: target1.typeDesc = \"unknown\";\n            }\n\n            // Add color description\n            switch(target1.color) {\n                case 0: target1.colorDesc = \"other\"; break;\n                case 1: target1.colorDesc = \"white\"; break;\n                case 2: target1.colorDesc = \"gray\"; break;\n                case 3: target1.colorDesc = \"yellow\"; break;\n                case 4: target1.colorDesc = \"pink\"; break;\n                case 5: target1.colorDesc = \"red\"; break;\n                case 6: target1.colorDesc = \"purple\"; break;\n                case 7: target1.colorDesc = \"green\"; break;\n                case 8: target1.colorDesc = \"blue\"; break;\n                case 9: target1.colorDesc = \"brown\"; break;\n                case 10: target1.colorDesc = \"black\"; break;\n                default: target1.colorDesc = \"unknown\";\n            }\n\n            // Header information\n            let header = {\n                frameType: parseInt(hexString.substring(8, 10), 16),\n                checksum: parseInt(hexString.substring(10, 12), 16),\n                deviceId: hexString.substring(16, 56),\n                timestamp: hexString.substring(56, 72),\n                numberOfTargets: parseInt(hexString.substring(72, 76), 16)\n            };\n\n            msg.payload = {\n                header: header,\n                target: target1\n            };\n\n        } catch (error) {\n            msg.payload = { \n                error: \"Error parsing data: \" + error.message,\n                details: \"Error occurred while processing the hex string\"\n            };\n        }\n    } else {\n        msg.payload = { error: \"Invalid or too short payload data\" };\n    }\n} else {\n    msg.payload = { error: \"Payload not found\" };\n}\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 250,
        "y": 400,
        "wires": [
            []
        ]
    },
    {
        "id": "e1bf5f7309d24c23",
        "type": "debug",
        "z": "e8bb17e4f6e25a56",
        "name": "debug 5",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 480,
        "y": 200,
        "wires": []
    },
    {
        "id": "18f04cb4c55de653",
        "type": "function",
        "z": "e8bb17e4f6e25a56",
        "name": "sniff only the speed only",
        "func": "// Check if payload exists and is valid\nif (msg.payload) {\n    let hexString = msg.payload;\n\n    // if (typeof hexString === \"string\" && hexString.length >= 76) {\n        try {\n            // Extract first target data section (starting at byte 39)\n            //let speed = (parseInt(hexString.substring(43, 44), 16) / 10);\n            let speed = hexString.readUInt16BE(42) / 10;\n            let speeds = parseInt(speed);\n            //  msg.payload = speed / 10;\n            // Only send the speed if it's 20 or above\n            if (speeds > 20) {\n                let numStr = speeds.toString();\n\n                // Convert each digit to its ASCII value (in hex)\n                let hexDigits = numStr.split('').map(digit => digit.charCodeAt(0).toString(16).toUpperCase());\n\n                // Combine into a buffer if needed\n                msg.payload = Buffer.from(hexDigits.map(d => parseInt(d, 16)));\n                //msg.payload = parseInt(speed);\n            } else {\n                //let number = 20;\n                //let numStr = number.toString();// or you can return nothing to ignore the message\n                                // Convert each digit to its ASCII value (in hex)\n                //let hexDigits = numStr.split('').map(digit => digit.charCodeAt(0).toString(16).toUpperCase());\n\n                // Combine into a buffer if needed\n                //msg.payload = Buffer.from(hexDigits.map(d => parseInt(d, 16)));\n            }\n\n        } catch (error) {\n            msg.payload = { \n                error: \"Error parsing data: \" + error.message,\n                details: \"Error occurred while processing the hex string\"\n            };\n        }\n    // } else {\n    //     //msg.payload = { error: \"Invalid or too short payload data\" };\n    // }\n} else {\n    //msg.payload = { error: \"Payload not found\" };\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 430,
        "y": 280,
        "wires": [
            [
                "e1bf5f7309d24c23",
                "d4deec9dcf210da4"
            ]
        ]
    },
    {
        "id": "8e50ab9642568fee",
        "type": "function",
        "z": "e8bb17e4f6e25a56",
        "name": "slow down data trigger every 5 sec",
        "func": "// Get the current timestamp\nlet currentTime = Date.now();\n\n// Get the last allowed timestamp from context\nlet lastAllowedTime = context.get(\"lastAllowedTime\") || 0;\n\n// Set the delay time in milliseconds \nconst delayTime = 1000;\n\n// Check if enough time has passed\nif (currentTime - lastAllowedTime >= delayTime) {\n    // Update the last allowed timestamp\n    context.set(\"lastAllowedTime\", currentTime);\n    \n    // Allow the data to pass\n    return msg;\n} else {\n    // Drop or hold the message\n    return null;\n}\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 460,
        "wires": [
            [
                "1cb5d4845c520682"
            ]
        ]
    },
    {
        "id": "d4deec9dcf210da4",
        "type": "function",
        "z": "e8bb17e4f6e25a56",
        "name": "combine with the display",
        "func": "// let ByteHeader = \"4c 30 31 3F 32 33 01 D4 C1 42 51 32 32 38 46 2C CA B1 CB D9 31\"\n// let ByteFotter =\"6B 6D 2F 68 0D\"\n// let Speed = msg.payload\n\n\n// return msg;\n\n// Fixed parts as buffers\nlet part1 = Buffer.from([0x4C, 0x30, 0x31, 0x3F, 0x32, 0x33, 0x01, 0xD4, 0xC1, 0x42, 0x51, 0x32, 0x32, 0x38, 0x46, 0x2C, 0xCA, 0xB1, 0xCB, 0xD9]);\nlet part3 = Buffer.from([0x6B, 0x6D, 0x2F, 0x68, 0x0D]);\n\n// Dynamic part from msg.payload (expected as a buffer)\nlet part2 = Buffer.isBuffer(msg.payload) ? msg.payload : Buffer.from(msg.payload);\n\n// Combine all parts\nlet fullBuffer = Buffer.concat([part1, part2, part3]);\n\n// Output the combined buffer\nmsg.payload = fullBuffer;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 690,
        "y": 280,
        "wires": [
            [
                "8eba46cf15e52bce",
                "9944c15ec517dc59"
            ]
        ]
    },
    {
        "id": "8eba46cf15e52bce",
        "type": "debug",
        "z": "e8bb17e4f6e25a56",
        "name": "debug 6",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 720,
        "y": 200,
        "wires": []
    },
    {
        "id": "1cb5d4845c520682",
        "type": "debug",
        "z": "e8bb17e4f6e25a56",
        "name": "debug 7",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 780,
        "y": 500,
        "wires": []
    },
    {
        "id": "d2caaa20bfae5d0f",
        "type": "comment",
        "z": "e8bb17e4f6e25a56",
        "name": "From Radar to Display",
        "info": "",
        "x": 140,
        "y": 100,
        "wires": []
    },
    {
        "id": "20fc5bc4a589ff16",
        "type": "tcp in",
        "z": "e8bb17e4f6e25a56",
        "name": "",
        "server": "client",
        "host": "192.168.12.11",
        "port": "8998",
        "datamode": "stream",
        "datatype": "buffer",
        "newline": "",
        "topic": "",
        "trim": false,
        "base64": false,
        "tls": "",
        "x": 180,
        "y": 200,
        "wires": [
            [
                "9e6d1b1ffdff3777",
                "2b4c769f00542766"
            ]
        ]
    },
    {
        "id": "9944c15ec517dc59",
        "type": "serial out",
        "z": "e8bb17e4f6e25a56",
        "name": "Radar Display TCP",
        "serial": "499334b129b933ed",
        "x": 710,
        "y": 340,
        "wires": []
    },
    {
        "id": "2b4c769f00542766",
        "type": "debug",
        "z": "e8bb17e4f6e25a56",
        "name": "debug 1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 460,
        "y": 120,
        "wires": []
    },
    {
        "id": "600b684b44c4f626",
        "type": "debug",
        "z": "e8bb17e4f6e25a56",
        "name": "debug 18",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 380,
        "y": 60,
        "wires": []
    }
]