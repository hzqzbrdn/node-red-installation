[
    {
        "id": "c6fdc014f79c73d7",
        "type": "tab",
        "label": "radar count/classification",
        "disabled": false,
        "info": ""
    },
    {
        "id": "d3dfdfd513fb0aa2",
        "type": "tab",
        "label": "modbusSolar",
        "disabled": false,
        "info": ""
    },
    {
        "id": "e8bb17e4f6e25a56",
        "type": "tab",
        "label": "pushToLedDisplay",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "9cc0f956de129e15",
        "type": "group",
        "z": "d3dfdfd513fb0aa2",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "ae3ca7f3c39fa801",
            "f69ef20e49fd5e67",
            "0870edf5488db2a6"
        ],
        "x": 74,
        "y": 259,
        "w": 592,
        "h": 82
    },
    {
        "id": "b0abfd163ff60551",
        "type": "group",
        "z": "d3dfdfd513fb0aa2",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "49e26240e82539d0",
            "02420378b682d2a9",
            "15d703f186d11b28",
            "a01ae8ea72715992",
            "5f7aa11225841d0b"
        ],
        "x": 74,
        "y": 79,
        "w": 672,
        "h": 162
    },
    {
        "id": "3d91f4f35a4e74d0",
        "type": "group",
        "z": "e8bb17e4f6e25a56",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "20fc5bc4a589ff16",
            "9e6d1b1ffdff3777",
            "d28347799e7e47c1",
            "18f04cb4c55de653",
            "d4deec9dcf210da4",
            "8eba46cf15e52bce",
            "9944c15ec517dc59",
            "2f5e2d0559847e11",
            "fd3e93d63d5687ce",
            "d2caaa20bfae5d0f"
        ],
        "x": 54,
        "y": -1,
        "w": 832,
        "h": 442
    },
    {
        "id": "3c63bc47f335e16f",
        "type": "group",
        "z": "c6fdc014f79c73d7",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "5c387bf597313272",
            "6af15a9e987a0b63",
            "c00a95d04f85d204",
            "6af2a7d381f9eaf0"
        ],
        "x": 34,
        "y": 79,
        "w": 612,
        "h": 202
    },
    {
        "id": "f176d52d.8a5d98",
        "type": "tls-config",
        "name": "",
        "cert": "",
        "key": "",
        "ca": "",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "",
        "verifyservercert": true
    },
    {
        "id": "f52ff211.a533d",
        "type": "mqtt-broker",
        "z": "c6fdc014f79c73d7",
        "name": "",
        "broker": "mqtts://broker.react.net.my",
        "port": "1883",
        "tls": "f176d52d.8a5d98",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "7459e1c0f90208e3",
        "type": "serial-port",
        "z": "d3dfdfd513fb0aa2",
        "name": "solar-batery",
        "serialport": "/dev/ttyS3",
        "serialbaud": "9600",
        "databits": "8",
        "parity": "none",
        "stopbits": "1",
        "waitfor": "",
        "dtr": "none",
        "rts": "none",
        "cts": "none",
        "dsr": "none",
        "newline": "200",
        "bin": "bin",
        "out": "time",
        "addchar": "",
        "responsetimeout": "10000"
    },
    {
        "id": "499334b129b933ed",
        "type": "serial-port",
        "z": "e8bb17e4f6e25a56",
        "name": "",
        "serialport": "/dev/ttyS0",
        "serialbaud": "9600",
        "databits": 8,
        "parity": "none",
        "stopbits": 1,
        "waitfor": "",
        "dtr": "none",
        "rts": "none",
        "cts": "none",
        "dsr": "none",
        "newline": "\\n",
        "bin": "bin",
        "out": "char",
        "addchar": "",
        "responsetimeout": 10000
    },
    {
        "id": "57ac84494075ccc8",
        "type": "serial-port",
        "z": "d3dfdfd513fb0aa2",
        "name": "",
        "serialport": "/dev/ttyS0",
        "serialbaud": "9600",
        "databits": 8,
        "parity": "none",
        "stopbits": 1,
        "waitfor": "",
        "dtr": "none",
        "rts": "none",
        "cts": "none",
        "dsr": "none",
        "newline": "\\n",
        "bin": "bin",
        "out": "char",
        "addchar": "",
        "responsetimeout": 10000
    },
    {
        "id": "951f201ab53ccfb0",
        "type": "serial-port",
        "z": "d3dfdfd513fb0aa2",
        "name": "",
        "serialport": "/dev/ttyS0",
        "serialbaud": "9600",
        "databits": 8,
        "parity": "none",
        "stopbits": 1,
        "waitfor": "",
        "dtr": "none",
        "rts": "none",
        "cts": "none",
        "dsr": "none",
        "newline": "\\n",
        "bin": "bin",
        "out": "char",
        "addchar": "",
        "responsetimeout": 10000
    },
    {
        "id": "db51e67223e51d73",
        "type": "mqtt-broker",
        "name": "",
        "broker": "mqtts://broker.react.net.my",
        "port": 1883,
        "tls": "f176d52d.8a5d98",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "394275e31b267799",
        "type": "mqtt-broker",
        "name": "react 2",
        "broker": "broker.react.net.my",
        "port": "8883",
        "tls": "f176d52d.8a5d98",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "2054b162aec9c313",
        "type": "mqtt-broker",
        "name": "",
        "broker": "broker.react.net.my",
        "port": "8883",
        "tls": "f176d52d.8a5d98",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "3745fc1041a7d39d",
        "type": "mqtt-broker",
        "name": "",
        "broker": "128.199.147.18",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "c00a95d04f85d204",
        "type": "mqtt out",
        "z": "c6fdc014f79c73d7",
        "g": "3c63bc47f335e16f",
        "name": "new broker",
        "topic": "/data/traffic/radar03/",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "f52ff211.a533d",
        "x": 550,
        "y": 120,
        "wires": []
    },
    {
        "id": "5c387bf597313272",
        "type": "tcp in",
        "z": "c6fdc014f79c73d7",
        "g": "3c63bc47f335e16f",
        "name": "",
        "server": "client",
        "host": "192.168.12.11",
        "port": "8998",
        "datamode": "stream",
        "datatype": "buffer",
        "newline": "",
        "topic": "",
        "trim": false,
        "base64": false,
        "tls": "",
        "x": 160,
        "y": 140,
        "wires": [
            [
                "6af15a9e987a0b63"
            ]
        ]
    },
    {
        "id": "2924467d7f1b989c",
        "type": "comment",
        "z": "c6fdc014f79c73d7",
        "name": "",
        "info": "Couting accurately.",
        "x": 300,
        "y": 60,
        "wires": []
    },
    {
        "id": "6af15a9e987a0b63",
        "type": "function",
        "z": "c6fdc014f79c73d7",
        "g": "3c63bc47f335e16f",
        "name": "Counting and Classification",
        "func": "const HEADER = Buffer.from([0x55, 0xAA, 0x55, 0xBB]);\nconst FOOTER = Buffer.from([0x55, 0xCC, 0x55, 0xDD]);\nconst packet = Buffer.from(msg.payload, 'hex'); // Convert HEX string to Buffer\n\nconst TARGET_TYPES = {\n    0x01: \"C6\", 0x02: \"C6\", 0x03: \"C6\", 0x04: \"C5\",\n    0x05: \"C2\", 0x06: \"C1\", 0x07: \"C1\", 0x08: \"C4\",\n    0x09: \"C3\", 0x0A: \"C3\", 0x0C: \"C4\", 0x0E: \"C2\"\n};\n\nif (!packet.subarray(0, HEADER.length).equals(HEADER) ||\n    !packet.subarray(packet.length - FOOTER.length).equals(FOOTER)) {\n    node.warn(\"Invalid packet: Missing HEADER or FOOTER\");\n    return null;\n}\n\nconst typeByte = packet[HEADER.length];\nif (typeByte !== 0x05) return null;\n\nconst checksum = packet[5];\nconst deviceIDBuffer = packet.subarray(8, 28);\nconst deviceID = deviceIDBuffer.toString('hex');\n\nconst timestampMs = packet.readBigUInt64BE(28);\nconst malaysiaOffset = 8 * 60 * 60 * 1000;\nconst timestampDate = new Date(Number(timestampMs) + malaysiaOffset);\nconst formattedTimestamp = timestampDate.toISOString();\n\nconst numEntries = packet.readUInt16BE(36);\nlet offset = 38;\nconst PASS_DATA_SIZE = 23;\nlet passData = [];\n\nfor (let i = 0; i < numEntries; i++) {\n    if (packet.length < offset + PASS_DATA_SIZE) break;\n    const entryData = packet.subarray(offset, offset + PASS_DATA_SIZE);\n\n    // Check occupancy status at byte index 18.\n    // If not \"Entering\" (i.e. value 1), ignore this target.\n    const occupancyStatus = entryData.readUInt8(18);\n    if (occupancyStatus !== 1) {\n        offset += PASS_DATA_SIZE;\n        continue;\n    }\n\n    const laneNumber = entryData.readUInt16BE(0);\n    const vehicleSpeed = (entryData.readUInt16BE(4) / 10.0);\n    const targetTypeRaw = entryData.readUInt8(19);\n    const targetType = TARGET_TYPES[targetTypeRaw] || \"other\";\n\n    passData.push({\n        lane: laneNumber,\n        class: targetType,\n        speed: vehicleSpeed\n    });\n    offset += PASS_DATA_SIZE;\n}\n\n// If no targets meet the \"Entering\" criteria, completely ignore the packet.\nif (passData.length === 0) {\n    return null;\n}\n\nmsg.payload = {\n    header: {\n        frameType: typeByte,\n        checksum: checksum,\n        deviceId: deviceID,\n        timestamp: formattedTimestamp,\n        numberOfTargets: passData.length\n    },\n    target: passData[0]\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 180,
        "wires": [
            [
                "c00a95d04f85d204",
                "6af2a7d381f9eaf0"
            ]
        ]
    },
    {
        "id": "6af2a7d381f9eaf0",
        "type": "debug",
        "z": "c6fdc014f79c73d7",
        "g": "3c63bc47f335e16f",
        "name": "debug 12",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 500,
        "y": 240,
        "wires": []
    },
    {
        "id": "02420378b682d2a9",
        "type": "debug",
        "z": "d3dfdfd513fb0aa2",
        "g": "b0abfd163ff60551",
        "name": "",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 330,
        "y": 120,
        "wires": []
    },
    {
        "id": "5f7aa11225841d0b",
        "type": "mqtt out",
        "z": "d3dfdfd513fb0aa2",
        "g": "b0abfd163ff60551",
        "name": "",
        "topic": "smart/solar/0000000000000001",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "db51e67223e51d73",
        "x": 590,
        "y": 200,
        "wires": []
    },
    {
        "id": "a01ae8ea72715992",
        "type": "debug",
        "z": "d3dfdfd513fb0aa2",
        "g": "b0abfd163ff60551",
        "name": "",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 530,
        "y": 120,
        "wires": []
    },
    {
        "id": "f69ef20e49fd5e67",
        "type": "function",
        "z": "d3dfdfd513fb0aa2",
        "g": "9cc0f956de129e15",
        "name": "Read-Command",
        "func": "// Define the command to request 22 registers starting from 0x200\n// let commandHex = \"41160F0100009D0A0B0B04020016211A2B\";\nlet commandHex = \"01040200001A7079\"\n\n// Convert the hex string to a Buffer object\nmsg.payload = Buffer.from(commandHex, 'hex');\n\n// Send the command to the serial out node\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 340,
        "y": 300,
        "wires": [
            [
                "0870edf5488db2a6"
            ]
        ]
    },
    {
        "id": "ae3ca7f3c39fa801",
        "type": "inject",
        "z": "d3dfdfd513fb0aa2",
        "g": "9cc0f956de129e15",
        "name": "",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "*/10 0-23 * * *",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "str",
        "x": 170,
        "y": 300,
        "wires": [
            [
                "f69ef20e49fd5e67"
            ]
        ]
    },
    {
        "id": "49e26240e82539d0",
        "type": "serial in",
        "z": "d3dfdfd513fb0aa2",
        "g": "b0abfd163ff60551",
        "name": "",
        "serial": "7459e1c0f90208e3",
        "x": 170,
        "y": 180,
        "wires": [
            [
                "02420378b682d2a9",
                "15d703f186d11b28"
            ]
        ]
    },
    {
        "id": "0870edf5488db2a6",
        "type": "serial out",
        "z": "d3dfdfd513fb0aa2",
        "g": "9cc0f956de129e15",
        "name": "command request",
        "serial": "7459e1c0f90208e3",
        "x": 550,
        "y": 300,
        "wires": []
    },
    {
        "id": "15d703f186d11b28",
        "type": "function",
        "z": "d3dfdfd513fb0aa2",
        "g": "b0abfd163ff60551",
        "name": "Decode battery",
        "func": "let buf = Buffer.isBuffer(msg.payload) ? msg.payload : Buffer.from(msg.payload);\nif (buf.length < 3) return null;\n\n// Define metadata\nconst deveui = \"0250f4000000\"; // change this if needed\nconst ipAdress = \"http://192.168.13.1\";\nconst devicename = \"bivocom-13\";\n\nconst byteCount = buf[2];\nconst data = buf.slice(3, 3 + byteCount);\n\nlet payload = {\n    deveui,\n    ipAdress,\n    devicename,\n    alarm: null,\n    remainingAh: null,\n    batterySoc: null,\n    humidity: null,\n    batteryPower: null,\n    totalBatteryVoltage: null,\n    totalBatteryCurrent: null,\n    batteryChargingCurrent: null,\n    batteryDischargeCurrent: null,\n    temperatures1: null,\n    temperatures2: null,\n    remainingHours: null,\n    remainingDays: null\n};\n\n// Parse registers from 0x0200 onward\nfor (let i = 0; i < data.length; i += 2) {\n    let addr = 0x0200 + (i / 2);\n    let raw = data.readUInt16BE(i);\n\n    switch (addr) {\n        case 0x0201: // Warning information 1\n            payload.alarm = raw;\n            break;\n        case 0x0203: // Number of AH remaining\n            payload.remainingAh = raw / 10;\n            break;\n        case 0x0204: // Residual power SOC / PWM duty\n            payload.batterySoc = raw >> 8;\n            payload.humidity = raw & 0xFF;\n            break;\n        case 0x0205: // Power of battery (W)\n            payload.batteryPower = raw;\n            break;\n        case 0x0206: // Total battery voltage\n            payload.totalBatteryVoltage = raw / 10;\n            break;\n        case 0x0207: // Total battery current\n            payload.totalBatteryCurrent = (raw > 32767 ? raw - 65536 : raw) / 10;\n            break;\n        case 0x0208: // Charging current\n            payload.batteryChargingCurrent = (raw > 32767 ? raw - 65536 : raw) / 100;\n            break;\n        case 0x0209: // Discharge current\n            payload.batteryDischargeCurrent = (raw > 32767 ? raw - 65536 : raw) / 100;\n            break;\n        case 0x020A: // Temperature 1/2\n            let temp1 = raw >> 8;\n            let temp2 = raw & 0xFF;\n            if (temp1 > 127) temp1 -= 256;\n            if (temp2 > 127) temp2 -= 256;\n            payload.temperatures1 = temp1;\n            payload.temperatures2 = temp2;\n            break;\n        case 0x0214: // Internal timestamp (low 16 bits)\n            payload.remainingHours = raw;\n            break;\n        case 0x0215: // Remaining days\n            payload.remainingDays = raw;\n            break;\n    }\n}\n\n// Final output\nmsg.payload = payload;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 160,
        "wires": [
            [
                "a01ae8ea72715992",
                "5f7aa11225841d0b"
            ]
        ]
    },
    {
        "id": "9e6d1b1ffdff3777",
        "type": "function",
        "z": "e8bb17e4f6e25a56",
        "g": "3d91f4f35a4e74d0",
        "name": "sniff from 00x05",
        "func": "const HEADER = Buffer.from([0x55, 0xAA, 0x55, 0xBB]);\nconst packet = Buffer.from(msg.payload);\nconst typeByte = packet[HEADER.length];\n\nif (typeByte === 0x05) {\n   msg.payload = packet.toString('hex').toUpperCase();\n   msg.payload = packet;\n   if(msg.payload.length === 64){\n    // let speed = hexString.readUInt16BE(42) / 10;\n    // let speeds = parseInt(speed);\n    //         //  msg.payload = speed / 10;\n    //         // Only send the speed if it's 20 or above\n    //     if (speeds > 20) {\n    //         let numStr = speeds.toString();\n    //             // Convert each digit to its ASCII value (in hex)\n    //         let hexDigits = numStr.split('').map(digit => digit.charCodeAt(0).toString(16).toUpperCase());\n\n    //             // Combine into a buffer if needed\n    //         msg.payload = Buffer.from(hexDigits.map(d => parseInt(d, 16)));\n    //             //msg.payload = parseInt(speed);\n    //         }       \n    return msg;   \n   }\n   \n}\n//return null;\n\n// && packet.length == 128",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 200,
        "y": 280,
        "wires": [
            [
                "d28347799e7e47c1",
                "18f04cb4c55de653"
            ]
        ]
    },
    {
        "id": "d28347799e7e47c1",
        "type": "function",
        "z": "e8bb17e4f6e25a56",
        "g": "3d91f4f35a4e74d0",
        "name": "decode data",
        "func": "// Check if payload exists and is valid\nif (msg.payload) {\n    let hexString = msg.payload;\n\n    if (typeof hexString === \"string\" && hexString.length >= 76) {\n        try {\n            // Extract first target data section (starting at byte 39)\n            let target1 = {\n                // Target ID (10 bytes)\n                targetId: hexString.substring(76, 96),\n                \n                // Target Lane (1 byte)\n                lane: parseInt(hexString.substring(96, 98), 16),\n                \n                // Target Type (1 byte)\n                type: parseInt(hexString.substring(98, 100), 16),\n                \n                // Color (1 byte)\n                color: parseInt(hexString.substring(100, 102), 16),\n                \n                // Skip plate number (12 bytes of zeros)\n                \n                // X Coordinate (2 bytes) - might be negative\n                xCoord: (parseInt(hexString.substring(126, 130), 16) << 16 >> 16) / 10,\n                \n                // Y Coordinate (2 bytes)\n                yCoord: parseInt(hexString.substring(130, 134), 16) / 10,\n                \n                // Speed (2 bytes)\n                speed: (parseInt(hexString.substring(134, 138), 16) / 10) * 3.6,\n                \n                // Image X axis (2 bytes)\n                imageX: parseInt(hexString.substring(138, 142), 16),\n                \n                // Image Y axis (2 bytes)\n                imageY: parseInt(hexString.substring(142, 146), 16),\n                \n                // Target Azimuth Angle (2 bytes)\n                azimuth: parseInt(hexString.substring(154, 158), 16) / 10,\n                \n                // Vehicle dimensions (1 byte each)\n                length: parseInt(hexString.substring(158, 160), 16) / 10,\n                width: parseInt(hexString.substring(160, 162), 16) / 10,\n                height: parseInt(hexString.substring(162, 164), 16) / 10,\n                \n                // Parking status (1 byte)\n                parkingStatus: parseInt(hexString.substring(164, 166), 16),\n                \n                // Direction speeds (2 bytes each)\n                xSpeed: (parseInt(hexString.substring(166, 170), 16) << 16 >> 16) / 10,\n                ySpeed: (parseInt(hexString.substring(170, 174), 16) << 16 >> 16) / 10,\n                \n                // Acceleration values (2 bytes each)\n                motionAccel: (parseInt(hexString.substring(174, 178), 16) << 16 >> 16) / 100,\n                xAccel: (parseInt(hexString.substring(178, 182), 16) << 16 >> 16) / 100,\n                yAccel: (parseInt(hexString.substring(182, 186), 16) << 16 >> 16) / 100,\n                \n                // Location (4 bytes each)\n                longitude: parseInt(hexString.substring(186, 194), 16) / 10000000,\n                latitude: parseInt(hexString.substring(194, 202), 16) / 10000000\n            };\n\n            // Add type description\n            switch(target1.type) {\n                case 0: target1.typeDesc = \"other\"; break;\n                case 1: target1.typeDesc = \"C6\"; break;\n                case 2: target1.typeDesc = \"C6\"; break;\n                case 3: target1.typeDesc = \"tricycle\"; break;\n                case 4: target1.typeDesc = \"C5\"; break;\n                case 5: target1.typeDesc = \"C3\"; break;\n                case 6: target1.typeDesc = \"C1\"; break;\n                case 7: target1.typeDesc = \"C2\"; break;\n                case 8: target1.typeDesc = \"C4\"; break;\n                case 9: target1.typeDesc = \"C4\"; break;\n                case 10: target1.typeDesc = \"C3\"; break;\n                case 11: target1.typeDesc = \"C4\"; break;\n                case 12: target1.typeDesc = \"C4\"; break;\n                case 13: target1.typeDesc = \"person\"; break;\n                case 14: target1.typeDesc = \"c5\"; break;\n                default: target1.typeDesc = \"unknown\";\n            }\n\n            // Add color description\n            switch(target1.color) {\n                case 0: target1.colorDesc = \"other\"; break;\n                case 1: target1.colorDesc = \"white\"; break;\n                case 2: target1.colorDesc = \"gray\"; break;\n                case 3: target1.colorDesc = \"yellow\"; break;\n                case 4: target1.colorDesc = \"pink\"; break;\n                case 5: target1.colorDesc = \"red\"; break;\n                case 6: target1.colorDesc = \"purple\"; break;\n                case 7: target1.colorDesc = \"green\"; break;\n                case 8: target1.colorDesc = \"blue\"; break;\n                case 9: target1.colorDesc = \"brown\"; break;\n                case 10: target1.colorDesc = \"black\"; break;\n                default: target1.colorDesc = \"unknown\";\n            }\n\n            // Header information\n            let header = {\n                frameType: parseInt(hexString.substring(8, 10), 16),\n                checksum: parseInt(hexString.substring(10, 12), 16),\n                deviceId: hexString.substring(16, 56),\n                timestamp: hexString.substring(56, 72),\n                numberOfTargets: parseInt(hexString.substring(72, 76), 16)\n            };\n\n            msg.payload = {\n                header: header,\n                target: target1\n            };\n\n        } catch (error) {\n            msg.payload = { \n                error: \"Error parsing data: \" + error.message,\n                details: \"Error occurred while processing the hex string\"\n            };\n        }\n    } else {\n        msg.payload = { error: \"Invalid or too short payload data\" };\n    }\n} else {\n    msg.payload = { error: \"Payload not found\" };\n}\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 250,
        "y": 400,
        "wires": [
            []
        ]
    },
    {
        "id": "18f04cb4c55de653",
        "type": "function",
        "z": "e8bb17e4f6e25a56",
        "g": "3d91f4f35a4e74d0",
        "name": "sniff only the speed only",
        "func": "// Check if payload exists and is valid\nif (msg.payload) {\n    let hexString = msg.payload;\n\n    // if (typeof hexString === \"string\" && hexString.length >= 76) {\n        try {\n            // Extract first target data section (starting at byte 39)\n            //let speed = (parseInt(hexString.substring(43, 44), 16) / 10);\n            let speed = hexString.readUInt16BE(42) / 10;\n            let speeds = parseInt(speed);\n            //  msg.payload = speed / 10;\n            // Only send the speed if it's 20 or above\n            if (speeds > 20) {\n                let numStr = speeds.toString();\n\n                // Convert each digit to its ASCII value (in hex)\n                let hexDigits = numStr.split('').map(digit => digit.charCodeAt(0).toString(16).toUpperCase());\n\n                // Combine into a buffer if needed\n                msg.payload = Buffer.from(hexDigits.map(d => parseInt(d, 16)));\n                //msg.payload = parseInt(speed);\n            } else {\n                //let number = 20;\n                //let numStr = number.toString();// or you can return nothing to ignore the message\n                                // Convert each digit to its ASCII value (in hex)\n                //let hexDigits = numStr.split('').map(digit => digit.charCodeAt(0).toString(16).toUpperCase());\n\n                // Combine into a buffer if needed\n                //msg.payload = Buffer.from(hexDigits.map(d => parseInt(d, 16)));\n            }\n\n        } catch (error) {\n            msg.payload = { \n                error: \"Error parsing data: \" + error.message,\n                details: \"Error occurred while processing the hex string\"\n            };\n        }\n    // } else {\n    //     //msg.payload = { error: \"Invalid or too short payload data\" };\n    // }\n} else {\n    //msg.payload = { error: \"Payload not found\" };\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 430,
        "y": 280,
        "wires": [
            [
                "d4deec9dcf210da4"
            ]
        ]
    },
    {
        "id": "d4deec9dcf210da4",
        "type": "function",
        "z": "e8bb17e4f6e25a56",
        "g": "3d91f4f35a4e74d0",
        "name": "combine with the display",
        "func": "// let ByteHeader = \"4c 30 31 3F 32 33 01 D4 C1 42 51 32 32 38 46 2C CA B1 CB D9 31\"\n// let ByteFotter =\"6B 6D 2F 68 0D\"\n// let Speed = msg.payload\n\n\n// return msg;\n\n// Fixed parts as buffers\nlet part1 = Buffer.from([0x4C, 0x30, 0x31, 0x3F, 0x32, 0x33, 0x01, 0xD4, 0xC1, 0x42, 0x51, 0x32, 0x32, 0x38, 0x46, 0x2C, 0xCA, 0xB1, 0xCB, 0xD9]);\nlet part3 = Buffer.from([0x6B, 0x6D, 0x2F, 0x68, 0x0D]);\n\n// Dynamic part from msg.payload (expected as a buffer)\nlet part2 = Buffer.isBuffer(msg.payload) ? msg.payload : Buffer.from(msg.payload);\n\n// Combine all parts\nlet fullBuffer = Buffer.concat([part1, part2, part3]);\n\n// Output the combined buffer\nmsg.payload = fullBuffer;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 690,
        "y": 280,
        "wires": [
            [
                "8eba46cf15e52bce",
                "9944c15ec517dc59"
            ]
        ]
    },
    {
        "id": "8eba46cf15e52bce",
        "type": "debug",
        "z": "e8bb17e4f6e25a56",
        "g": "3d91f4f35a4e74d0",
        "name": "debug 6",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 720,
        "y": 200,
        "wires": []
    },
    {
        "id": "d2caaa20bfae5d0f",
        "type": "comment",
        "z": "e8bb17e4f6e25a56",
        "g": "3d91f4f35a4e74d0",
        "name": "From Radar to Display",
        "info": "",
        "x": 200,
        "y": 100,
        "wires": []
    },
    {
        "id": "20fc5bc4a589ff16",
        "type": "tcp in",
        "z": "e8bb17e4f6e25a56",
        "g": "3d91f4f35a4e74d0",
        "name": "",
        "server": "client",
        "host": "192.168.12.11",
        "port": "8998",
        "datamode": "stream",
        "datatype": "buffer",
        "newline": "",
        "topic": "",
        "trim": false,
        "base64": false,
        "tls": "",
        "x": 180,
        "y": 200,
        "wires": [
            [
                "9e6d1b1ffdff3777"
            ]
        ]
    },
    {
        "id": "9944c15ec517dc59",
        "type": "serial out",
        "z": "e8bb17e4f6e25a56",
        "g": "3d91f4f35a4e74d0",
        "name": "Radar Display TCP",
        "serial": "499334b129b933ed",
        "x": 710,
        "y": 340,
        "wires": []
    },
    {
        "id": "2f5e2d0559847e11",
        "type": "mqtt in",
        "z": "e8bb17e4f6e25a56",
        "g": "3d91f4f35a4e74d0",
        "name": "",
        "topic": "radar/data",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "3745fc1041a7d39d",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 620,
        "y": 100,
        "wires": [
            [
                "9944c15ec517dc59",
                "fd3e93d63d5687ce"
            ]
        ]
    },
    {
        "id": "fd3e93d63d5687ce",
        "type": "debug",
        "z": "e8bb17e4f6e25a56",
        "g": "3d91f4f35a4e74d0",
        "name": "debug 2",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 780,
        "y": 40,
        "wires": []
    },
    {
        "id": "8f1fb012e72e0477",
        "type": "global-config",
        "env": [],
        "modules": {
            "node-red-node-serialport": "2.0.3"
        }
    }
]