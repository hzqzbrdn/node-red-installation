[{"id":"c6fdc014f79c73d7","type":"tab","label":"radar03","disabled":false,"info":""},{"id":"d3dfdfd513fb0aa2","type":"tab","label":"modbusSolar","disabled":false,"info":""},{"id":"e8bb17e4f6e25a56","type":"tab","label":"pushToLedDisplay","disabled":false,"info":"","env":[]},{"id":"b2e8ff8ae08e43af","type":"tab","label":"radar-testing","disabled":false,"info":"","env":[]},{"id":"f176d52d.8a5d98","type":"tls-config","name":"","cert":"","key":"","ca":"","certname":"","keyname":"","caname":"","servername":"","verifyservercert":true},{"id":"f52ff211.a533d","type":"mqtt-broker","z":"c6fdc014f79c73d7","name":"","broker":"mqtts://broker.react.net.my","port":"1883","tls":"f176d52d.8a5d98","clientid":"","autoConnect":true,"usetls":true,"protocolVersion":"4","keepalive":"60","cleansession":true,"autoUnsubscribe":true,"birthTopic":"","birthQos":"0","birthPayload":"","birthMsg":{},"closeTopic":"","closeQos":"0","closePayload":"","closeMsg":{},"willTopic":"","willQos":"0","willPayload":"","willMsg":{},"userProps":"","sessionExpiry":""},{"id":"7459e1c0f90208e3","type":"serial-port","z":"d3dfdfd513fb0aa2","name":"solar-batery","serialport":"/dev/ttyS0","serialbaud":"9600","databits":"8","parity":"none","stopbits":"1","waitfor":"","dtr":"none","rts":"none","cts":"none","dsr":"none","newline":"200","bin":"bin","out":"time","addchar":"","responsetimeout":"10000"},{"id":"499334b129b933ed","type":"serial-port","z":"e8bb17e4f6e25a56","name":"","serialport":"/dev/ttyS3","serialbaud":"9600","databits":8,"parity":"none","stopbits":1,"waitfor":"","dtr":"none","rts":"none","cts":"none","dsr":"none","newline":"\\n","bin":"bin","out":"char","addchar":"","responsetimeout":10000},{"id":"57ac84494075ccc8","type":"serial-port","z":"d3dfdfd513fb0aa2","name":"","serialport":"/dev/ttyS0","serialbaud":"9600","databits":8,"parity":"none","stopbits":1,"waitfor":"","dtr":"none","rts":"none","cts":"none","dsr":"none","newline":"\\n","bin":"bin","out":"char","addchar":"","responsetimeout":10000},{"id":"951f201ab53ccfb0","type":"serial-port","z":"d3dfdfd513fb0aa2","name":"","serialport":"/dev/ttyS0","serialbaud":"9600","databits":8,"parity":"none","stopbits":1,"waitfor":"","dtr":"none","rts":"none","cts":"none","dsr":"none","newline":"\\n","bin":"bin","out":"char","addchar":"","responsetimeout":10000},{"id":"9afd6c7ab542425b","type":"influxdb","z":"c6fdc014f79c73d7","hostname":"192.168.1.175","port":8086,"protocol":"http","database":"vehicle_data","name":"InfluxDB","usetls":false,"tls":"","influxdbVersion":"1.x","url":"http://localhost:8086","timeout":10,"rejectUnauthorized":true},{"id":"881e97f4d20694e0","type":"influxdb","z":"c6fdc014f79c73d7","d":true,"hostname":"192.168.1.175","port":8086,"protocol":"http","database":"vehicle_data","name":"","usetls":false,"tls":"","influxdbVersion":"1.x","url":"http://localhost:8086","timeout":10,"rejectUnauthorized":true},{"id":"db51e67223e51d73","type":"mqtt-broker","name":"","broker":"mqtts://broker.react.net.my","port":1883,"tls":"f176d52d.8a5d98","clientid":"","autoConnect":true,"usetls":true,"protocolVersion":4,"keepalive":60,"cleansession":true,"autoUnsubscribe":true,"birthTopic":"","birthQos":"0","birthRetain":"false","birthPayload":"","birthMsg":{},"closeTopic":"","closeQos":"0","closeRetain":"false","closePayload":"","closeMsg":{},"willTopic":"","willQos":"0","willRetain":"false","willPayload":"","willMsg":{},"userProps":"","sessionExpiry":""},{"id":"394275e31b267799","type":"mqtt-broker","name":"react 2","broker":"broker.react.net.my","port":"8883","tls":"f176d52d.8a5d98","clientid":"","autoConnect":true,"usetls":true,"protocolVersion":4,"keepalive":60,"cleansession":true,"autoUnsubscribe":true,"birthTopic":"","birthQos":"0","birthRetain":"false","birthPayload":"","birthMsg":{},"closeTopic":"","closeQos":"0","closeRetain":"false","closePayload":"","closeMsg":{},"willTopic":"","willQos":"0","willRetain":"false","willPayload":"","willMsg":{},"userProps":"","sessionExpiry":""},{"id":"2054b162aec9c313","type":"mqtt-broker","name":"","broker":"broker.react.net.my","port":"8883","tls":"f176d52d.8a5d98","clientid":"","autoConnect":true,"usetls":true,"protocolVersion":4,"keepalive":60,"cleansession":true,"autoUnsubscribe":true,"birthTopic":"","birthQos":"0","birthRetain":"false","birthPayload":"","birthMsg":{},"closeTopic":"","closeQos":"0","closeRetain":"false","closePayload":"","closeMsg":{},"willTopic":"","willQos":"0","willRetain":"false","willPayload":"","willMsg":{},"userProps":"","sessionExpiry":""},{"id":"f68dc5435e0f6a82","type":"function","z":"c6fdc014f79c73d7","d":true,"name":"0x01 Object Data (Hex)","func":"const HEADER = Buffer.from([0x55, 0xAA, 0x55, 0xBB]);\nconst packet = Buffer.from(msg.payload);\nconst typeByte = packet[HEADER.length];\n\nif (typeByte === 0x01) {\n   msg.payload = packet.toString('hex').toUpperCase();\n   return msg;\n}\nreturn null;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":150,"y":380,"wires":[["7cc68d56ba135843"]]},{"id":"7cc68d56ba135843","type":"function","z":"c6fdc014f79c73d7","d":true,"name":"Decode 00x01 Function","func":"// Create or use an existing global array to store seen cyclicIds\nlet cyclicIds = global.get(\"cyclicIds\") || [];\n\n// Check if the global array size needs to be reset (clear every 5 minutes)\nlet resetIntervalMs = 5 * 60 * 1000; // 5 minutes in milliseconds\nlet lastResetTime = global.get(\"lastResetTime\") || 0;\nlet currentTime = Date.now();\n\nif (currentTime - lastResetTime >= resetIntervalMs) {\n    cyclicIds = []; // Clear the cyclicIds array\n    global.set(\"cyclicIds\", cyclicIds); // Save the cleared array\n    global.set(\"lastResetTime\", currentTime); // Update the reset timestamp\n    node.warn(\"Global cyclicIds array reset.\");\n}\n\n// Proceed with normal processing if payload exists\nif (msg.payload) {\n    let hexString = msg.payload;\n\n    if (typeof hexString === \"string\" && hexString.length >= 76) {\n        try {\n            // Header parsing\n            let header = {\n                frameType: parseInt(hexString.substring(8, 10), 16),\n                checksum: parseInt(hexString.substring(10, 12), 16),\n                deviceId: hexString.substring(16, 56),\n\n                // Parse Data Timestamp\n                timestamp: (() => {\n                    let rawTimestamp = parseInt(hexString.substring(56, 72), 16);\n                    if (rawTimestamp > 0 && rawTimestamp < 4102444800000) {\n                        // Divide by 1000 if timestamp is in milliseconds\n                        if (rawTimestamp > 4102444800) {\n                            rawTimestamp = Math.floor(rawTimestamp / 1000);\n                        }\n                        let malaysiaTime = new Date(rawTimestamp * 1000);\n                        malaysiaTime.setHours(malaysiaTime.getHours() + 8); // Add UTC+8\n                        return malaysiaTime.toISOString();\n                    } else {\n                        return \"Invalid timestamp: \" + rawTimestamp;\n                    }\n                })(),\n\n                numberOfTargets: parseInt(hexString.substring(72, 76), 16)\n            };\n\n            // Ignore messages with no targets\n            if (header.numberOfTargets === 0) {\n                return null;\n            }\n\n            // Target Data parsing\n            let targetDataStart = 76; // Byte 39\n            let target1 = {\n                // Target ID parsing\n                targetId: (() => {\n                    let targetTimestamp = parseInt(hexString.substring(targetDataStart, targetDataStart + 16), 16);\n                    let cyclicId = parseInt(hexString.substring(targetDataStart + 16, targetDataStart + 20), 16);\n\n                    // Convert timestamp to a readable date if valid\n                    let date = new Date(targetTimestamp); // Convert milliseconds since epoch to a date\n                    date.setHours(date.getHours() + 8);   // Adjust to Malaysia Time (UTC+8)\n                    let timestamp = date.toISOString();  // Format as ISO 8601\n\n                    return {\n                        timestamp: timestamp,\n                        cyclicId: cyclicId\n                    };\n                })(),\n\n                lane: parseInt(hexString.substring(targetDataStart + 20, targetDataStart + 22), 16),\n\n                // Type and color mapping\n                class: (() => {\n                    let type = parseInt(hexString.substring(targetDataStart + 22, targetDataStart + 24), 16);\n                    let typeMap = {\n                        0x00: \"other\",\n                        0x01: \"C6\",\n                        0x02: \"C6\",\n                        0x03: \"tricycle\",\n                        0x04: \"C5\",\n                        0x05: \"C3\",\n                        0x06: \"C1\",\n                        0x07: \"C2\",\n                        0x08: \"C4\",\n                        0x09: \"C4\",\n                        0x0A: \"C3\",\n                        0x0B: \"C4\",\n                        0x0C: \"C4\",\n                        0x0D: \"person\",\n                        0x0E: \"C5\"\n                    };\n                    return typeMap[type] || \"unknown\";\n                })(),\n\n\n                color: (() => {\n                    let color = parseInt(hexString.substring(targetDataStart + 24, targetDataStart + 26), 16);\n                    let colorMap = {\n                        0x00: \"other\",\n                        0x01: \"white\",\n                        0x02: \"gray\",\n                        0x03: \"yellow\",\n                        0x04: \"pink\",\n                        0x05: \"red\",\n                        0x06: \"purple\",\n                        0x07: \"green\",\n                        0x08: \"blue\",\n                        0x09: \"brown\",\n                        0x0A: \"black\"\n                    };\n                    return { value: color, description: colorMap[color] || \"unknown\" };\n                })(),\n\n                // Coordinates and metrics\n                xCoord: (parseInt(hexString.substring(targetDataStart + 50, targetDataStart + 54), 16) << 16 >> 16) / 10,\n                yCoord: parseInt(hexString.substring(targetDataStart + 54, targetDataStart + 58), 16) / 10,\n                speed: Math.round((parseInt(hexString.substring(targetDataStart + 58, targetDataStart + 62), 16) / 10) * 3.6),\n                imageX: parseInt(hexString.substring(targetDataStart + 62, targetDataStart + 66), 16),\n                imageY: parseInt(hexString.substring(targetDataStart + 66, targetDataStart + 70), 16),\n\n                // Dimensions\n                length: parseInt(hexString.substring(targetDataStart + 82, targetDataStart + 84), 16) / 10,\n                width: parseInt(hexString.substring(targetDataStart + 84, targetDataStart + 86), 16) / 10,\n                height: Math.round((parseInt(hexString.substring(targetDataStart + 86, targetDataStart + 88), 16) / 10) * 100) / 100 // Round to 2 decimal places\n\n            };\n\n            // Additional checks to ignore invalid or \"empty\" data\n            if (\n                target1.targetId.cyclicId == null || \n                target1.lane == null || \n                target1.xCoord === 0 || \n                target1.speed === 0\n            ) {\n                return null;\n            }\n\n            // Check if cyclicId already exists in the global list\n            if (cyclicIds.includes(target1.targetId.cyclicId)) {\n                // If cyclicId exists, do not output the msg\n                return null;\n            } else {\n                // If cyclicId is new, add it to the global list and output the msg\n                cyclicIds.push(target1.targetId.cyclicId);\n                global.set(\"cyclicIds\", cyclicIds);\n\n                msg.payload = {\n                    header: header,\n                    target: target1\n                };\n\n                return msg;\n            }\n        } catch (error) {\n            msg.payload = {\n                error: \"Error parsing data: \" + error.message,\n                details: \"Error occurred while processing the hex string\"\n            };\n        }\n    } else {\n        msg.payload = { error: \"Invalid or too short payload data\" };\n    }\n} else {\n    msg.payload = { error: \"Payload not found\" };\n}\n\nreturn msg;\n","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":590,"y":420,"wires":[["13cd0344a397cd76"]]},{"id":"13cd0344a397cd76","type":"debug","z":"c6fdc014f79c73d7","name":"","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":810,"y":460,"wires":[]},{"id":"c00a95d04f85d204","type":"mqtt out","z":"c6fdc014f79c73d7","name":"new broker","topic":"/data/traffic/radar03/","qos":"","retain":"","respTopic":"","contentType":"","userProps":"","correl":"","expiry":"","broker":"f52ff211.a533d","x":830,"y":120,"wires":[]},{"id":"5c387bf597313272","type":"tcp in","z":"c6fdc014f79c73d7","name":"","server":"client","host":"192.168.12.11","port":"8998","datamode":"stream","datatype":"buffer","newline":"","topic":"","trim":false,"base64":false,"tls":"","x":240,"y":220,"wires":[["f68dc5435e0f6a82","73acad919265db71","6af15a9e987a0b63"]]},{"id":"73acad919265db71","type":"function","z":"c6fdc014f79c73d7","d":true,"name":"0x04 Traffic Flow Statistical Data (Hex)","func":"const HEADER = Buffer.from([0x55, 0xAA, 0x55, 0xBB]);\nconst packet = Buffer.from(msg.payload);\nconst typeByte = packet[HEADER.length];\n\nif (typeByte === 0x03) {\n   msg.payload = packet.toString('hex').toUpperCase();\n   return msg;\n}\nreturn null;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":210,"y":440,"wires":[["86d3f55f3c1d4c9c"]]},{"id":"86d3f55f3c1d4c9c","type":"function","z":"c6fdc014f79c73d7","d":true,"name":"decode","func":"if (msg.payload) {\n    let hexString = msg.payload;\n    try {\n        // Convert hex string to bytes array\n        const bytes = [];\n        for (let i = 0; i < hexString.length; i += 2) {\n            bytes.push(parseInt(hexString.substr(i, 2), 16));\n        }\n\n        let offset = 38; // Start of data\n        msg.payload = {\n            statisticalPeriod: (bytes[offset] << 8) | bytes[offset + 1],\n            targetLane: (bytes[offset + 2] << 8) | bytes[offset + 3],\n            monitoringLocation: ((bytes[offset + 4] << 8) | bytes[offset + 5]) / 10.0,\n            bicycleFlow: (bytes[offset + 6] << 8) | bytes[offset + 7],\n            motorcycleFlow: (bytes[offset + 8] << 8) | bytes[offset + 9],\n            tricycleFlow: (bytes[offset + 10] << 8) | bytes[offset + 11],\n            busFlow: (bytes[offset + 12] << 8) | bytes[offset + 13],\n            vanFlow: (bytes[offset + 14] << 8) | bytes[offset + 15],\n            carFlow: (bytes[offset + 16] << 8) | bytes[offset + 17],\n            suvFlow: (bytes[offset + 18] << 8) | bytes[offset + 19],\n            largeTruckFlow: (bytes[offset + 20] << 8) | bytes[offset + 21],\n            mediumTruckFlow: (bytes[offset + 22] << 8) | bytes[offset + 23],\n            lightTruckFlow: (bytes[offset + 24] << 8) | bytes[offset + 25],\n            dangerousGoodsFlow: (bytes[offset + 26] << 8) | bytes[offset + 27],\n            engineeringVehiclesFlow: (bytes[offset + 28] << 8) | bytes[offset + 29],\n            pedestrianFlow: (bytes[offset + 30] << 8) | bytes[offset + 31],\n            totalFlow: (bytes[offset + 32] << 8) | bytes[offset + 33],\n            averageVehicleSpeed: ((bytes[offset + 34] << 8) | bytes[offset + 35]) / 10.0,\n            headwayTime: (bytes[offset + 36] << 8) | bytes[offset + 37],\n            virtualLoopOccupancyRate: ((bytes[offset + 38] << 8) | bytes[offset + 39]) / 10.0,\n            maximumQueueLength: ((bytes[offset + 40] << 8) | bytes[offset + 41]) / 10.0,\n            laneSpaceOccupancyRate: ((bytes[offset + 42] << 8) | bytes[offset + 43]) / 10.0,\n            vehicleSpacing: ((bytes[offset + 44] << 8) | bytes[offset + 45]) / 10.0,\n            trafficDensity: ((bytes[offset + 46] << 8) | bytes[offset + 47]) / 10.0\n        };\n\n    } catch (error) {\n        msg.payload = { error: \"Error parsing data\" };\n    }\n}\nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":600,"y":500,"wires":[[]]},{"id":"2924467d7f1b989c","type":"comment","z":"c6fdc014f79c73d7","name":"","info":"Couting accurately.","x":300,"y":60,"wires":[]},{"id":"0492acbbe989f731","type":"function","z":"c6fdc014f79c73d7","d":true,"name":"Format for InfluxDB","func":"var data = msg.payload;\n\n// Extract relevant fields\nvar classType = data.target.class; // Example: \"C1\"\nvar deviceId = data.header.deviceId;\nvar timestamp = new Date(data.header.timestamp).getTime() * 1000000; // Convert to nanoseconds\n\n// Prepare InfluxDB payload\nmsg.payload = [\n    {\n        measurement: \"vehicle_counts\",\n        tags: {\n            deviceId: deviceId\n        },\n        fields: {\n            [classType]: 1 // Store class as a field with value 1 (for counting)\n        },\n        timestamp: timestamp\n    }\n];\n\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":840,"y":320,"wires":[["d521d3c3f5f81b97"]]},{"id":"d521d3c3f5f81b97","type":"influxdb out","z":"c6fdc014f79c73d7","d":true,"influxdb":"9afd6c7ab542425b","name":"InfluxDB","measurement":"","precision":"n","retentionPolicy":"","database":"database","precisionV18FluxV20":"ms","retentionPolicyV18Flux":"","org":"organisation","bucket":"bucket","x":1040,"y":400,"wires":[]},{"id":"6af15a9e987a0b63","type":"function","z":"c6fdc014f79c73d7","name":"Counting and Classification","func":"const HEADER = Buffer.from([0x55, 0xAA, 0x55, 0xBB]);\nconst FOOTER = Buffer.from([0x55, 0xCC, 0x55, 0xDD]);\nconst packet = Buffer.from(msg.payload, 'hex'); // Convert HEX string to Buffer\n\nconst TARGET_TYPES = {\n    0x01: \"C6\", 0x02: \"C6\", 0x03: \"C6\", 0x04: \"C5\",\n    0x05: \"C2\", 0x06: \"C1\", 0x07: \"C1\", 0x08: \"C4\",\n    0x09: \"C3\", 0x0A: \"C3\", 0x0C: \"C4\", 0x0E: \"C2\"\n};\n\nif (!packet.subarray(0, HEADER.length).equals(HEADER) ||\n    !packet.subarray(packet.length - FOOTER.length).equals(FOOTER)) {\n    node.warn(\"Invalid packet: Missing HEADER or FOOTER\");\n    return null;\n}\n\nconst typeByte = packet[HEADER.length];\nif (typeByte !== 0x05) return null;\n\nconst checksum = packet[5];\nconst deviceIDBuffer = packet.subarray(8, 28);\nconst deviceID = deviceIDBuffer.toString('hex');\n\nconst timestampMs = packet.readBigUInt64BE(28);\nconst malaysiaOffset = 8 * 60 * 60 * 1000;\nconst timestampDate = new Date(Number(timestampMs) + malaysiaOffset);\nconst formattedTimestamp = timestampDate.toISOString();\n\nconst numEntries = packet.readUInt16BE(36);\nlet offset = 38;\nconst PASS_DATA_SIZE = 23;\nlet passData = [];\n\nfor (let i = 0; i < numEntries; i++) {\n    if (packet.length < offset + PASS_DATA_SIZE) break;\n    const entryData = packet.subarray(offset, offset + PASS_DATA_SIZE);\n\n    // Check occupancy status at byte index 18.\n    // If not \"Entering\" (i.e. value 1), ignore this target.\n    const occupancyStatus = entryData.readUInt8(18);\n    if (occupancyStatus !== 1) {\n        offset += PASS_DATA_SIZE;\n        continue;\n    }\n\n    const laneNumber = entryData.readUInt16BE(0);\n    const vehicleSpeed = (entryData.readUInt16BE(4) / 10.0);\n    const targetTypeRaw = entryData.readUInt8(19);\n    const targetType = TARGET_TYPES[targetTypeRaw] || \"other\";\n\n    passData.push({\n        lane: laneNumber,\n        class: targetType,\n        speed: vehicleSpeed\n    });\n    offset += PASS_DATA_SIZE;\n}\n\n// If no targets meet the \"Entering\" criteria, completely ignore the packet.\nif (passData.length === 0) {\n    return null;\n}\n\nmsg.payload = {\n    header: {\n        frameType: typeByte,\n        checksum: checksum,\n        deviceId: deviceID,\n        timestamp: formattedTimestamp,\n        numberOfTargets: passData.length\n    },\n    target: passData[0]\n};\n\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":460,"y":140,"wires":[["c00a95d04f85d204","6af2a7d381f9eaf0","83f004897ee34c50"]]},{"id":"6af2a7d381f9eaf0","type":"debug","z":"c6fdc014f79c73d7","name":"debug 12","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":620,"y":260,"wires":[]},{"id":"83f004897ee34c50","type":"function","z":"c6fdc014f79c73d7","d":true,"name":"function 5","func":"// Map existing data directly to InfluxDB without changing anything\n// Extract values directly from the message payload\nconst deviceId = msg.payload.header.deviceId;\nconst timestamp = msg.payload.header.timestamp;\nconst lane = msg.payload.target.lane;\nconst vehicleClass = msg.payload.target.class;\nconst speed = msg.payload.target.speed;\n\n// Set the measurement name directly in msg.measurement as required by the InfluxDB node\nmsg.measurement = \"vehicle_detections\";\n\n// Format the data for InfluxDB without transformation\nmsg.payload = [{\n    // measurement is now set in msg.measurement, not needed here\n    tags: {\n        deviceId: deviceId,\n        lane: lane,\n        vehicleClass: vehicleClass\n    },\n    fields: {\n        speed: speed\n    },\n    timestamp: new Date(timestamp).getTime() * 1000000 // Convert ISO timestamp to nanoseconds\n}];\n\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":440,"y":320,"wires":[["1f10502c862c6108"]]},{"id":"1f10502c862c6108","type":"debug","z":"c6fdc014f79c73d7","name":"debug 11","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":620,"y":320,"wires":[]},{"id":"ba3f955836dd6411","type":"function","z":"d3dfdfd513fb0aa2","name":"decode data","func":"// Input buffer\nlet buffer = msg.payload; // Assuming msg.payload contains the buffer data\n\nbuffer = buffer.slice(0,72);\n// Decode registers directly into msg.payload\nmsg.payload = {\n    alarmStatus: (buffer[15] << 8) | buffer[16], // 16-bit value\n    remainingAh: ((buffer[17] << 8) | buffer[18]) / 10, // 16-bit value, scaled by 10\n    remainingSoC: buffer[19], // 8-bit value\n    humidity: buffer[20], // 8-bit value\n    batteryPower: ((buffer[21] << 8) | buffer[22]) / 10, // 16-bit value, scaled by 10\n    totalBatteryVoltage: ((buffer[23] << 8) | buffer[24]) / 10, // 16-bit value, scaled by 10\n    // totalBatteryCurrent: ((buffer[25] << 8) | buffer[26]) / 10, // 16-bit value, scaled by 10\n    batteryChargingCurrent: ((buffer[27] << 8) | buffer[28]) / 100, // 16-bit value, scaled by 100\n    batteryDischargingCurrent: ((buffer[29] << 8) | buffer[30]) / 100, // 16-bit value, scaled by 100\n    Temp1: buffer[31], // 8-bit value\n    Temp2: buffer[32], // 8-bit value\n   // clampingVoltage: ((buffer[47] << 8) | buffer[48]) / 10 // 16-bit value, scaled by 10\n    // Uncomment the lines below if needed:\n    // internalTimestamp: ((buffer[49] << 8) | buffer[50]), // 16-bit value\n    // remainingNumberOfDays: ((buffer[52] << 8) | buffer[53]) / 100 // 16-bit value, scaled by 100\n};\n\n// Return the decoded data\nreturn msg;\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":730,"y":80,"wires":[["0f9698fea83a10c4"]]},{"id":"0f9698fea83a10c4","type":"debug","z":"d3dfdfd513fb0aa2","name":"","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":890,"y":80,"wires":[]},{"id":"02420378b682d2a9","type":"debug","z":"d3dfdfd513fb0aa2","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":530,"y":60,"wires":[]},{"id":"5f7aa11225841d0b","type":"mqtt out","z":"d3dfdfd513fb0aa2","name":"","topic":"smart/solar/0000000000000001","qos":"","retain":"","respTopic":"","contentType":"","userProps":"","correl":"","expiry":"","broker":"db51e67223e51d73","x":1190,"y":320,"wires":[]},{"id":"7708ede44e016d0a","type":"function","z":"d3dfdfd513fb0aa2","name":"","func":"// Input buffer\nlet buffer = msg.payload; // Assuming msg.payload contains the buffer data\n\n// Check if buffer has at least 55 elements (buffer[54] exists)\nif (buffer && buffer.length > 53) {\n    // Decode the buffer into the desired JSON format\n    msg.payload = {\n        deveui: \"0000000000000001\",\n        ipAdress: \"http://192.168.12.1\", // Static value, replace as needed\n        devicename: \"elastel\",  // Static value, replace as needed\n        timestamp: Date.now(), // Current timestamp in milliseconds\n        alarmInformation: (buffer[15] << 8) | buffer[16], // 16-bit value\n        batteryChargingCurrent: ((buffer[27] << 8) | buffer[28]) / 100, // 16-bit value, scaled by 100\n        batteryDischargeCurrent: ((buffer[29] << 8) | buffer[30]) / 100, // 16-bit value, scaled by 100\n        batteryPower: ((buffer[21] << 8) | buffer[22]), // 16-bit value, scaled by 10\n        batterySoC: buffer[19], // 8-bit value\n        clampingVoltage: ((buffer[47] << 8) | buffer[48]) / 10, // 16-bit value, scaled by 10\n        controlInformation: (buffer[11] << 8) | buffer[12], // Example static value, replace if dynamic\n        internalTimestampHigh: ((buffer[49] << 8) | buffer[50]), // 16-bit value\n        internalTimestampLow: ((buffer[51] << 8) | buffer[52]), // 16-bit value\n        remainingAH: ((buffer[17] << 8) | buffer[18]) / 10, // 16-bit value, scaled by 10\n        remainingDays: ((buffer[52] << 8) | buffer[53]) / 100, // 16-bit value, scaled by 100\n        temperatures1: buffer[31], // 8-bit value\n        temperatures2: buffer[32], // 8-bit value\n        totalBatteryCurrent: ((buffer[25] << 8) | buffer[26]) / 10, // 16-bit value, scaled by 10\n        totalBatteryVoltage: ((buffer[23] << 8) | buffer[24]) / 10, // 16-bit value, scaled by 10\n        humidity: buffer[20]\n    };\n} else {\n    // If buffer[54] doesn't exist, return an empty message or a warning\n    msg.payload = { error: \"Buffer length is insufficient\" };\n}\n\nreturn msg;\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":740,"y":180,"wires":[["a01ae8ea72715992"]]},{"id":"a01ae8ea72715992","type":"debug","z":"d3dfdfd513fb0aa2","name":"","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":970,"y":200,"wires":[]},{"id":"ff4e245b16e85dab","type":"function","z":"d3dfdfd513fb0aa2","name":"","func":"\n// Input buffer\nlet buffer = msg.payload; // Assuming msg.payload contains the buffer data\n\n// Convert buffer to an array of hex values\nlet hexArray = Array.from(buffer, byte => byte.toString(16).padStart(2, '0'));\n\n// Construct the output\nmsg.payload = {\n    // originalBuffer: buffer,\n    hexRepresentation: hexArray.join(\" \") // Combine hex values into a single string\n};\n\nreturn msg;\n","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":540,"y":180,"wires":[["b2faa1afe512a80c","8a9d785e6a5edac1","5cfb238b3a200525"]]},{"id":"b2faa1afe512a80c","type":"debug","z":"d3dfdfd513fb0aa2","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":730,"y":220,"wires":[]},{"id":"e563708f3023885b","type":"function","z":"d3dfdfd513fb0aa2","name":"Full-Decode-based-docs","func":"let buffer = msg.payload;\n\nbuffer = buffer.slice(11, 62)\n\nfunction toHex(num) {\n    return \"0x\" + num.toString(16).padStart(2, '0').toUpperCase();\n}\n\n// Protocol fields remain in hex\nlet startFlag = toHex(buffer[0]);\nlet headerInfo = toHex(buffer[1]);\nlet controlInfo = toHex(buffer[2]);\nlet messageLength = toHex(buffer[3]);\nlet fragmentOffset = toHex((buffer[4] << 8) | buffer[5]);\nlet commandData = toHex(buffer[6]);\nlet commandBytes = [toHex(buffer[7]), toHex(buffer[8]), toHex(buffer[9])];\nlet errorCode = toHex(buffer[10]);\nlet functionCode = toHex(buffer[11]);\nlet startAddress = toHex((buffer[12] << 8) | buffer[13]);\nlet registerCount = toHex(buffer[14]);\n\n// Battery data all in decimal\nlet alarmInformation = (buffer[15] << 8) | buffer[16];\nlet remainingAH = ((buffer[17] << 8) | buffer[18]) / 10;\nlet batterySoC = buffer[19];\nlet humidity = buffer[20];\nlet batteryPower = (buffer[21] << 8) | buffer[22];\nlet totalBatteryVoltage = ((buffer[23] << 8) | buffer[24]) / 10;\nlet totalBatteryCurrent = ((buffer[25] << 8) | buffer[26]) / 10;\nlet batteryChargingCurrent = ((buffer[27] << 8) | buffer[28]) / 100;\nlet batteryDischargeCurrent = ((buffer[29] << 8) | buffer[30]) / 100;\n\n// Temperature readings - convert to decimal except \"Not installed\"\nlet temperatures = [];\nfor (let i = 0; i < 8; i++) {\n    let temp1 = buffer[31 + i * 2];\n    let temp2 = buffer[32 + i * 2];\n    temperatures.push({\n        temp1: temp1 === 0xCE ? \"Not installed\" : temp1,\n        temp2: temp2 === 0xCE ? \"Not installed\" : temp2\n    });\n}\n\n// CRC and end flag remain in hex\nlet crc = toHex((buffer[buffer.length - 3] << 8) | buffer[buffer.length - 2]);\nlet endFlag = toHex(buffer[buffer.length - 1]);\n\nmsg.payload = {\n    protocol: {\n        startFlag: startFlag,\n        headerInfo: headerInfo,\n        controlInfo: controlInfo,\n        messageLength: messageLength,\n        fragmentOffset: fragmentOffset,\n        commandData: commandData,\n        commandBytes: commandBytes,\n        errorCode: errorCode,\n        functionCode: functionCode,\n        startAddress: startAddress,\n        registerCount: registerCount\n    },\n    batteryData: {\n        alarmInformation: alarmInformation,\n        remainingAH: remainingAH,\n        batterySoC: batterySoC,\n        humidity: humidity,\n        batteryPower: batteryPower,\n        totalBatteryVoltage: totalBatteryVoltage,\n        totalBatteryCurrent: totalBatteryCurrent,\n        batteryChargingCurrent: batteryChargingCurrent,\n        batteryDischargeCurrent: batteryDischargeCurrent,\n        temperatures: temperatures\n    },\n    verification: {\n        crc: crc,\n        endFlag: endFlag\n    }\n};\n\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":290,"y":300,"wires":[["eec3995c4100cde7"]]},{"id":"f69ef20e49fd5e67","type":"function","z":"d3dfdfd513fb0aa2","name":"Read-Command","func":"// Define the command to request 22 registers starting from 0x200\n// let commandHex = \"41160F0100009D0A0B0B04020016211A2B\";\nlet commandHex = \"41160F0100003A0A0B0B0402021221B92B\"\n\n// Convert the hex string to a Buffer object\nmsg.payload = Buffer.from(commandHex, 'hex');\n\n// Send the command to the serial out node\nreturn msg;\n","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":300,"y":680,"wires":[["0870edf5488db2a6"]]},{"id":"ae3ca7f3c39fa801","type":"inject","z":"d3dfdfd513fb0aa2","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"*/10 0-23 * * *","once":true,"onceDelay":0.1,"topic":"","payload":"","payloadType":"str","x":210,"y":540,"wires":[["f69ef20e49fd5e67"]]},{"id":"eec3995c4100cde7","type":"debug","z":"d3dfdfd513fb0aa2","name":"debug 9","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":460,"y":400,"wires":[]},{"id":"80565d49ed58925c","type":"function","z":"d3dfdfd513fb0aa2","name":"batteryData Decode","func":"let buffer = msg.payload;\n\nbuffer = buffer.slice(0,61);\n// Function to convert numbers to hex format\nfunction toHex(num) {\n    return \"0x\" + num.toString(16).padStart(2, '0').toUpperCase();\n}\n\n// Convert 16-bit value to signed int16 using two's complement\nfunction toInt16(highByte, lowByte) {\n    let value = (highByte << 8) | lowByte;\n    return value > 0x7FFF ? value - 0x10000 : value;\n}\n\n// // Check if buffer length matches expected size\n// if (buffer.length !== 63) {\n//     node.warn(\"Buffer length is not 54. Passing message without decoding.\");\n//     return msg; // Pass through without changes\n// }\n\n// Decode protocol fields\nlet startFlag = toHex(buffer[0]);\nlet headerInfo = toHex(buffer[1]);\nlet controlInfo = toHex(buffer[2]);\nlet messageLength = toHex(buffer[3]);\nlet fragmentOffset = toHex((buffer[4] << 8) | buffer[5]);\nlet commandData = toHex(buffer[6]);\nlet commandBytes = [toHex(buffer[7]), toHex(buffer[8]), toHex(buffer[9])];\nlet errorCode = toHex(buffer[10]);\nlet functionCode = toHex(buffer[11]);\nlet startAddress = toHex((buffer[12] << 8) | buffer[13]);\nlet registerCount = toHex(buffer[14]);\n\n// Battery data\nlet alarmInformation = (buffer[15] << 8) | buffer[16];\nlet remainingAH = ((buffer[17] << 8) | buffer[18]) / 10;\nlet batterySoC = buffer[19];\nlet humidity = buffer[20];\nlet batteryPower = toInt16(buffer[21], buffer[22]);\nlet totalBatteryVoltage = ((buffer[23] << 8) | buffer[24]) / 10;\n// Convert currents to signed values\nlet totalBatteryCurrent = toInt16(buffer[25], buffer[26]) / 10;\nlet batteryChargingCurrent = toInt16(buffer[27], buffer[28]) / 100;\nlet batteryDischargeCurrent = toInt16(buffer[29], buffer[30]) / 100;\n\n// Extract first temperature pair\nlet temp1 = buffer[31] === 0xCE ? \"Not installed\" : buffer[31];\nlet temp2 = buffer[32] === 0xCE ? \"Not installed\" : buffer[32];\n\n// CRC and end flag remain in hex\nlet crc = toHex((buffer[buffer.length - 3] << 8) | buffer[buffer.length - 2]);\nlet endFlag = toHex(buffer[buffer.length - 1]);\n\n// Calculate net discharge current\nlet netDischargeCurrent = batteryDischargeCurrent - batteryChargingCurrent; // Net discharge current in A\n\n// Check if net discharge current is positive (battery is discharging)\nif (netDischargeCurrent > 0) {\n    // Calculate remaining hours and days based on real-time values\n    let remainingHours = remainingAH / netDischargeCurrent; // Remaining hours\n    let remainingDays = remainingHours / 24; // Remaining days\n\n    // Add calculated values to payload\n    msg.payload = {\n        batteryData: {\n            deveui: \"0000000000000001\",\n            ipAdress: \"http://192.168.12.254\",\n            devicename: \"elastel\",\n            alarmInformation: alarmInformation,\n            remainingAH: remainingAH,\n            batterySoC: batterySoC,\n            // humidity: humidity,\n            batteryPower: batteryPower,\n            totalBatteryVoltage: totalBatteryVoltage,\n            totalBatteryCurrent: totalBatteryCurrent,\n            batteryChargingCurrent: batteryChargingCurrent,\n            batteryDischargeCurrent: batteryDischargeCurrent,\n            temperatures1: temp1,\n            temperatures2: temp2,\n            remainingHours: remainingHours.toFixed(2), // Rounded to 2 decimal places\n            remainingDays: remainingDays.toFixed(2)  // Rounded to 2 decimal places\n        }\n    };\n} else {\n    // If the net discharge current is 0 or negative (charging or no load), display \"N/A\"\n    node.warn(\"Net discharge current is zero or negative, unable to calculate remaining life.\");\n    msg.payload = {\n        batteryData: {\n            deveui: \"0000000000000001\",\n            ipAdress: \"http://192.168.12.254\",\n            devicename: \"elastel\",\n            alarmInformation: alarmInformation,\n            remainingAH: remainingAH,\n            batterySoC: batterySoC,\n            // humidity: humidity,\n            batteryPower: batteryPower,\n            totalBatteryVoltage: totalBatteryVoltage,\n            totalBatteryCurrent: totalBatteryCurrent,\n            batteryChargingCurrent: batteryChargingCurrent,\n            batteryDischargeCurrent: batteryDischargeCurrent,\n            temperatures1: temp1,\n            temperatures2: temp2,\n            remainingHours: \"N/A\",\n            remainingDays: \"N/A\"\n        }\n    };\n}\n\nreturn msg;\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":740,"y":320,"wires":[["1be0298cc11e5371"]]},{"id":"1be0298cc11e5371","type":"debug","z":"d3dfdfd513fb0aa2","name":"debug 10","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":940,"y":280,"wires":[]},{"id":"50a1a20f3e3a035f","type":"debug","z":"d3dfdfd513fb0aa2","name":"debug 13","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":700,"y":540,"wires":[]},{"id":"4e3d7ac33429ccbe","type":"debug","z":"d3dfdfd513fb0aa2","name":"debug 14","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":920,"y":420,"wires":[]},{"id":"f0f34b43162e28ff","type":"function","z":"d3dfdfd513fb0aa2","name":"function 1","func":"var x = msg.payload;\nmsg.payload = x.slice(11, 62)\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":200,"y":440,"wires":[["9efa28ef98cd5407"]]},{"id":"9efa28ef98cd5407","type":"debug","z":"d3dfdfd513fb0aa2","name":"debug 15","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":480,"y":460,"wires":[]},{"id":"5cfb238b3a200525","type":"function","z":"d3dfdfd513fb0aa2","name":"function 2","func":"function decodeData(msg) {\n    const hexData = msg.payload.hexRepresentation.replace(/ /g, '');\n    const dataStart = 30;\n    const data = hexData.substring(dataStart);\n\n    function hexToDec(hex) {\n        if (!hex) return 0;\n        return parseInt(hex, 16);\n    }\n\n    // Function to convert hex to signed int8\n    function hexToSignedInt8(hex) {\n        let value = parseInt(hex, 16);\n        // Convert to signed 8-bit\n        if (value > 127) {\n            value = value - 256;\n        }\n        return value;\n    }\n\n    try {\n        // Decode temperatures (2*sint8 format)\n        // 0x020A is temp1/temp2\n        const temp1 = hexToSignedInt8(data.substring(32, 34)); // First byte\n        const temp2 = hexToSignedInt8(data.substring(34, 36)); // Second byte\n\n        // First decode all values\n        const remainingAh = (hexToDec(data.substring(4, 8)) / 10);\n        const dischargeCurrent = (hexToDec(data.substring(28, 32)) / 100);\n        const chargingCurrent = (hexToDec(data.substring(24, 28)) / 100);\n\n        // Calculate net discharge current\n        const netDischargeCurrent = parseFloat(dischargeCurrent) - parseFloat(chargingCurrent);\n\n        // Initialize remaining time values\n        let remainingHours = \"N/A\";\n        let remainingDays = 0;\n\n        // Calculate remaining time if discharging\n        if (netDischargeCurrent > 0) {\n            remainingHours = (parseFloat(remainingAh) / netDischargeCurrent).toFixed(2);\n            remainingDays = (parseFloat(remainingHours) / 24).toFixed(2);\n        }\n\n        // Create payload\n        msg.payload = {\n            deveui: \"0000000000000001\",\n            ipAdress: \"http://192.168.12.1\",\n            devicename: \"bivocom\",\n            alarm: hexToDec(data.substring(0, 4)),\n            remainingAh: remainingAh,\n            batterySoc: hexToDec(data.substring(8, 10)),\n            humidity: hexToDec(data.substring(10, 12)),\n            batteryPower: hexToDec(data.substring(12, 16)),\n            totalBatteryVoltage: (hexToDec(data.substring(16, 20)) / 10),\n            totalBatteryCurrent: ((hexToDec(data.substring(20, 24)) << 16 >> 16) / 10),\n            batteryChargingCurrent: chargingCurrent,\n            batteryDischargeCurrent: dischargeCurrent,\n            temperatures1: temp1,\n            temperatures2: temp2,\n            remainingHours: remainingHours,\n            remainingDays: remainingDays\n        };\n\n        return msg;\n\n    } catch (error) {\n        node.error(\"Error decoding data: \" + error.message);\n        return null;\n    }\n}\n\nreturn decodeData(msg);","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":700,"y":400,"wires":[["4e3d7ac33429ccbe","5f7aa11225841d0b"]]},{"id":"8a9d785e6a5edac1","type":"function","z":"d3dfdfd513fb0aa2","name":"function 3","func":"function decodeData(msg) {\n    const hexData = msg.payload.hexRepresentation.replace(/ /g, '');\n    const dataStart = 30;\n    const data = hexData.substring(dataStart);\n\n    function hexToDec(hex) {\n        if (!hex) return 0;\n        return parseInt(hex, 16);\n    }\n\n    // Function to convert hex to signed int8\n    function hexToSignedInt8(hex) {\n        let value = parseInt(hex, 16);\n        // Convert to signed 8-bit\n        if (value > 127) {\n            value = value - 256;\n        }\n        return value;\n    }\n\n    try {\n        // Decode temperatures (2*sint8 format)\n        // 0x020A is temp1/temp2\n        const temp1 = hexToSignedInt8(data.substring(32, 34)); // First byte\n        const temp2 = hexToSignedInt8(data.substring(34, 36)); // Second byte\n\n        // First decode all values\n        const remainingAh = (hexToDec(data.substring(4, 8)) / 10).toFixed(1);\n        const dischargeCurrent = (hexToDec(data.substring(28, 32)) / 100).toFixed(2);\n        const chargingCurrent = (hexToDec(data.substring(24, 28)) / 100).toFixed(2);\n\n        // Calculate net discharge current\n        const netDischargeCurrent = parseFloat(dischargeCurrent) - parseFloat(chargingCurrent);\n\n        // Initialize remaining time values\n        let remainingHours = \"N/A\";\n        let remainingDays = \"N/A\";\n\n        // Calculate remaining time if discharging\n        if (netDischargeCurrent > 0) {\n            remainingHours = (parseFloat(remainingAh) / netDischargeCurrent).toFixed(2);\n            remainingDays = (parseFloat(remainingHours) / 24).toFixed(2);\n        }\n\n        // Create payload\n        msg.payload = {\n            deveui: \"0000000000000001\",\n            ipAdress: \"http://192.168.12.254\",\n            devicename: \"elastel\",\n            alarm: hexToDec(data.substring(0, 4)),\n            remainingAh: remainingAh,\n            batterySoc: hexToDec(data.substring(8, 10)),\n            humidity: hexToDec(data.substring(10, 12)),\n            power: hexToDec(data.substring(12, 16)),\n            voltage: (hexToDec(data.substring(16, 20)) / 10).toFixed(1),\n            totalCurrent: ((hexToDec(data.substring(20, 24)) << 16 >> 16) / 10).toFixed(1),\n            chargingCurrent: chargingCurrent,\n            dischargeCurrent: dischargeCurrent,\n            temperatures1: temp1,\n            temperatures2: temp2,\n            remainingHours: remainingHours,\n            remainingDays: remainingDays\n        };\n\n        return msg;\n\n    } catch (error) {\n        node.error(\"Error decoding data: \" + error.message);\n        return null;\n    }\n}\n\nreturn decodeData(msg);","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":660,"y":460,"wires":[["81f3c0c393123c1a"]]},{"id":"81f3c0c393123c1a","type":"debug","z":"d3dfdfd513fb0aa2","name":"debug 16","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":860,"y":480,"wires":[]},{"id":"49e26240e82539d0","type":"serial in","z":"d3dfdfd513fb0aa2","name":"","serial":"7459e1c0f90208e3","x":170,"y":180,"wires":[["02420378b682d2a9","ff4e245b16e85dab","ba3f955836dd6411","f0f34b43162e28ff","9efa28ef98cd5407"]]},{"id":"0870edf5488db2a6","type":"serial out","z":"d3dfdfd513fb0aa2","name":"command request","serial":"7459e1c0f90208e3","x":550,"y":680,"wires":[]},{"id":"9e6d1b1ffdff3777","type":"function","z":"e8bb17e4f6e25a56","name":"sniff from 00x05","func":"const HEADER = Buffer.from([0x55, 0xAA, 0x55, 0xBB]);\nconst packet = Buffer.from(msg.payload);\nconst typeByte = packet[HEADER.length];\n\nif (typeByte === 0x05) {\n   msg.payload = packet.toString('hex').toUpperCase();\n   msg.payload = packet;\n   if(msg.payload.length === 64){\n    // let speed = hexString.readUInt16BE(42) / 10;\n    // let speeds = parseInt(speed);\n    //         //  msg.payload = speed / 10;\n    //         // Only send the speed if it's 20 or above\n    //     if (speeds > 20) {\n    //         let numStr = speeds.toString();\n    //             // Convert each digit to its ASCII value (in hex)\n    //         let hexDigits = numStr.split('').map(digit => digit.charCodeAt(0).toString(16).toUpperCase());\n\n    //             // Combine into a buffer if needed\n    //         msg.payload = Buffer.from(hexDigits.map(d => parseInt(d, 16)));\n    //             //msg.payload = parseInt(speed);\n    //         }       \n    return msg;   \n   }\n   \n}\n//return null;\n\n// && packet.length == 128","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":200,"y":280,"wires":[["d28347799e7e47c1","18f04cb4c55de653","600b684b44c4f626"]]},{"id":"d28347799e7e47c1","type":"function","z":"e8bb17e4f6e25a56","name":"decode data","func":"// Check if payload exists and is valid\nif (msg.payload) {\n    let hexString = msg.payload;\n\n    if (typeof hexString === \"string\" && hexString.length >= 76) {\n        try {\n            // Extract first target data section (starting at byte 39)\n            let target1 = {\n                // Target ID (10 bytes)\n                targetId: hexString.substring(76, 96),\n                \n                // Target Lane (1 byte)\n                lane: parseInt(hexString.substring(96, 98), 16),\n                \n                // Target Type (1 byte)\n                type: parseInt(hexString.substring(98, 100), 16),\n                \n                // Color (1 byte)\n                color: parseInt(hexString.substring(100, 102), 16),\n                \n                // Skip plate number (12 bytes of zeros)\n                \n                // X Coordinate (2 bytes) - might be negative\n                xCoord: (parseInt(hexString.substring(126, 130), 16) << 16 >> 16) / 10,\n                \n                // Y Coordinate (2 bytes)\n                yCoord: parseInt(hexString.substring(130, 134), 16) / 10,\n                \n                // Speed (2 bytes)\n                speed: (parseInt(hexString.substring(134, 138), 16) / 10) * 3.6,\n                \n                // Image X axis (2 bytes)\n                imageX: parseInt(hexString.substring(138, 142), 16),\n                \n                // Image Y axis (2 bytes)\n                imageY: parseInt(hexString.substring(142, 146), 16),\n                \n                // Target Azimuth Angle (2 bytes)\n                azimuth: parseInt(hexString.substring(154, 158), 16) / 10,\n                \n                // Vehicle dimensions (1 byte each)\n                length: parseInt(hexString.substring(158, 160), 16) / 10,\n                width: parseInt(hexString.substring(160, 162), 16) / 10,\n                height: parseInt(hexString.substring(162, 164), 16) / 10,\n                \n                // Parking status (1 byte)\n                parkingStatus: parseInt(hexString.substring(164, 166), 16),\n                \n                // Direction speeds (2 bytes each)\n                xSpeed: (parseInt(hexString.substring(166, 170), 16) << 16 >> 16) / 10,\n                ySpeed: (parseInt(hexString.substring(170, 174), 16) << 16 >> 16) / 10,\n                \n                // Acceleration values (2 bytes each)\n                motionAccel: (parseInt(hexString.substring(174, 178), 16) << 16 >> 16) / 100,\n                xAccel: (parseInt(hexString.substring(178, 182), 16) << 16 >> 16) / 100,\n                yAccel: (parseInt(hexString.substring(182, 186), 16) << 16 >> 16) / 100,\n                \n                // Location (4 bytes each)\n                longitude: parseInt(hexString.substring(186, 194), 16) / 10000000,\n                latitude: parseInt(hexString.substring(194, 202), 16) / 10000000\n            };\n\n            // Add type description\n            switch(target1.type) {\n                case 0: target1.typeDesc = \"other\"; break;\n                case 1: target1.typeDesc = \"C6\"; break;\n                case 2: target1.typeDesc = \"C6\"; break;\n                case 3: target1.typeDesc = \"tricycle\"; break;\n                case 4: target1.typeDesc = \"C5\"; break;\n                case 5: target1.typeDesc = \"C3\"; break;\n                case 6: target1.typeDesc = \"C1\"; break;\n                case 7: target1.typeDesc = \"C2\"; break;\n                case 8: target1.typeDesc = \"C4\"; break;\n                case 9: target1.typeDesc = \"C4\"; break;\n                case 10: target1.typeDesc = \"C3\"; break;\n                case 11: target1.typeDesc = \"C4\"; break;\n                case 12: target1.typeDesc = \"C4\"; break;\n                case 13: target1.typeDesc = \"person\"; break;\n                case 14: target1.typeDesc = \"c5\"; break;\n                default: target1.typeDesc = \"unknown\";\n            }\n\n            // Add color description\n            switch(target1.color) {\n                case 0: target1.colorDesc = \"other\"; break;\n                case 1: target1.colorDesc = \"white\"; break;\n                case 2: target1.colorDesc = \"gray\"; break;\n                case 3: target1.colorDesc = \"yellow\"; break;\n                case 4: target1.colorDesc = \"pink\"; break;\n                case 5: target1.colorDesc = \"red\"; break;\n                case 6: target1.colorDesc = \"purple\"; break;\n                case 7: target1.colorDesc = \"green\"; break;\n                case 8: target1.colorDesc = \"blue\"; break;\n                case 9: target1.colorDesc = \"brown\"; break;\n                case 10: target1.colorDesc = \"black\"; break;\n                default: target1.colorDesc = \"unknown\";\n            }\n\n            // Header information\n            let header = {\n                frameType: parseInt(hexString.substring(8, 10), 16),\n                checksum: parseInt(hexString.substring(10, 12), 16),\n                deviceId: hexString.substring(16, 56),\n                timestamp: hexString.substring(56, 72),\n                numberOfTargets: parseInt(hexString.substring(72, 76), 16)\n            };\n\n            msg.payload = {\n                header: header,\n                target: target1\n            };\n\n        } catch (error) {\n            msg.payload = { \n                error: \"Error parsing data: \" + error.message,\n                details: \"Error occurred while processing the hex string\"\n            };\n        }\n    } else {\n        msg.payload = { error: \"Invalid or too short payload data\" };\n    }\n} else {\n    msg.payload = { error: \"Payload not found\" };\n}\n\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":250,"y":400,"wires":[[]]},{"id":"e1bf5f7309d24c23","type":"debug","z":"e8bb17e4f6e25a56","name":"debug 5","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":480,"y":200,"wires":[]},{"id":"18f04cb4c55de653","type":"function","z":"e8bb17e4f6e25a56","name":"sniff only the speed only","func":"// Check if payload exists and is valid\nif (msg.payload) {\n    let hexString = msg.payload;\n\n    // if (typeof hexString === \"string\" && hexString.length >= 76) {\n        try {\n            // Extract first target data section (starting at byte 39)\n            //let speed = (parseInt(hexString.substring(43, 44), 16) / 10);\n            let speed = hexString.readUInt16BE(42) / 10;\n            let speeds = parseInt(speed);\n            //  msg.payload = speed / 10;\n            // Only send the speed if it's 20 or above\n            if (speeds > 20) {\n                let numStr = speeds.toString();\n\n                // Convert each digit to its ASCII value (in hex)\n                let hexDigits = numStr.split('').map(digit => digit.charCodeAt(0).toString(16).toUpperCase());\n\n                // Combine into a buffer if needed\n                msg.payload = Buffer.from(hexDigits.map(d => parseInt(d, 16)));\n                //msg.payload = parseInt(speed);\n            } else {\n                //let number = 20;\n                //let numStr = number.toString();// or you can return nothing to ignore the message\n                                // Convert each digit to its ASCII value (in hex)\n                //let hexDigits = numStr.split('').map(digit => digit.charCodeAt(0).toString(16).toUpperCase());\n\n                // Combine into a buffer if needed\n                //msg.payload = Buffer.from(hexDigits.map(d => parseInt(d, 16)));\n            }\n\n        } catch (error) {\n            msg.payload = { \n                error: \"Error parsing data: \" + error.message,\n                details: \"Error occurred while processing the hex string\"\n            };\n        }\n    // } else {\n    //     //msg.payload = { error: \"Invalid or too short payload data\" };\n    // }\n} else {\n    //msg.payload = { error: \"Payload not found\" };\n}\n\nreturn msg;\n","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":430,"y":280,"wires":[["e1bf5f7309d24c23","d4deec9dcf210da4"]]},{"id":"8e50ab9642568fee","type":"function","z":"e8bb17e4f6e25a56","name":"slow down data trigger every 5 sec","func":"// Get the current timestamp\nlet currentTime = Date.now();\n\n// Get the last allowed timestamp from context\nlet lastAllowedTime = context.get(\"lastAllowedTime\") || 0;\n\n// Set the delay time in milliseconds \nconst delayTime = 1000;\n\n// Check if enough time has passed\nif (currentTime - lastAllowedTime >= delayTime) {\n    // Update the last allowed timestamp\n    context.set(\"lastAllowedTime\", currentTime);\n    \n    // Allow the data to pass\n    return msg;\n} else {\n    // Drop or hold the message\n    return null;\n}\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":540,"y":460,"wires":[["1cb5d4845c520682"]]},{"id":"d4deec9dcf210da4","type":"function","z":"e8bb17e4f6e25a56","name":"combine with the display","func":"// let ByteHeader = \"4c 30 31 3F 32 33 01 D4 C1 42 51 32 32 38 46 2C CA B1 CB D9 31\"\n// let ByteFotter =\"6B 6D 2F 68 0D\"\n// let Speed = msg.payload\n\n\n// return msg;\n\n// Fixed parts as buffers\nlet part1 = Buffer.from([0x4C, 0x30, 0x31, 0x3F, 0x32, 0x33, 0x01, 0xD4, 0xC1, 0x42, 0x51, 0x32, 0x32, 0x38, 0x46, 0x2C, 0xCA, 0xB1, 0xCB, 0xD9]);\nlet part3 = Buffer.from([0x6B, 0x6D, 0x2F, 0x68, 0x0D]);\n\n// Dynamic part from msg.payload (expected as a buffer)\nlet part2 = Buffer.isBuffer(msg.payload) ? msg.payload : Buffer.from(msg.payload);\n\n// Combine all parts\nlet fullBuffer = Buffer.concat([part1, part2, part3]);\n\n// Output the combined buffer\nmsg.payload = fullBuffer;\nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":690,"y":280,"wires":[["8eba46cf15e52bce","9944c15ec517dc59"]]},{"id":"8eba46cf15e52bce","type":"debug","z":"e8bb17e4f6e25a56","name":"debug 6","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":720,"y":200,"wires":[]},{"id":"1cb5d4845c520682","type":"debug","z":"e8bb17e4f6e25a56","name":"debug 7","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":780,"y":500,"wires":[]},{"id":"d2caaa20bfae5d0f","type":"comment","z":"e8bb17e4f6e25a56","name":"From Radar to Display","info":"","x":140,"y":100,"wires":[]},{"id":"20fc5bc4a589ff16","type":"tcp in","z":"e8bb17e4f6e25a56","name":"","server":"client","host":"192.168.12.11","port":"8998","datamode":"stream","datatype":"buffer","newline":"","topic":"","trim":false,"base64":false,"tls":"","x":180,"y":200,"wires":[["9e6d1b1ffdff3777","2b4c769f00542766"]]},{"id":"9944c15ec517dc59","type":"serial out","z":"e8bb17e4f6e25a56","name":"Radar Display TCP","serial":"499334b129b933ed","x":710,"y":340,"wires":[]},{"id":"2b4c769f00542766","type":"debug","z":"e8bb17e4f6e25a56","name":"debug 1","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":460,"y":120,"wires":[]},{"id":"600b684b44c4f626","type":"debug","z":"e8bb17e4f6e25a56","name":"debug 18","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":380,"y":60,"wires":[]},{"id":"62f535aab1eb18cd","type":"inject","z":"b2e8ff8ae08e43af","name":"Connect","props":[{"p":"action","v":"connect","vt":"str"},{"p":"host","v":"192.168.12.11","vt":"str"},{"p":"port","v":"8998","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":170,"y":140,"wires":[["294b1fd02f433f5d"]]},{"id":"3f2b64ebe128ebe3","type":"debug","z":"b2e8ff8ae08e43af","name":"debug 2","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":580,"y":80,"wires":[]},{"id":"1ef22963dcff4f36","type":"function","z":"b2e8ff8ae08e43af","d":true,"name":"convert to hex","func":"const HEADER = Buffer.from([0x55, 0xAA, 0x55, 0xBB]);\nconst FOOTER = Buffer.from([0x55, 0xCC, 0x55, 0xDD]);\n\nfunction validatePacket(packet) {\n    // Check minimum length (header + type byte + footer)\n    if (packet.length < HEADER.length + 1 + FOOTER.length) {\n        return false;\n    }\n\n    // Check header\n    for (let i = 0; i < HEADER.length; i++) {\n        if (packet[i] !== HEADER[i]) {\n            return false;\n        }\n    }\n\n    // Check footer - look for footer pattern in last 20 bytes\n    let footerFound = false;\n    for (let i = packet.length - 20; i < packet.length - FOOTER.length + 1; i++) {\n        let matches = true;\n        for (let j = 0; j < FOOTER.length; j++) {\n            if (packet[i + j] !== FOOTER[j]) {\n                matches = false;\n                break;\n            }\n        }\n        if (matches) {\n            footerFound = true;\n            break;\n        }\n    }\n    return footerFound;\n}\n\nfunction decodeClassificationData(packet) {\n    // Skip header (4 bytes)\n    let offset = 4;\n\n    // Extract key fields based on protocol\n    const type = packet[offset++]; // Should be 0x01\n    const dataLength = packet.readUInt16BE(offset);\n    offset += 2;\n\n    // Skip checksum (1 byte)\n    offset++;\n\n    // Extract device ID (20 bytes)\n    const deviceId = packet.slice(offset, offset + 20).toString('ascii').replace(/\\0/g, '');\n    offset += 20;\n\n    // Extract timestamp (8 bytes)\n    const timestamp = new Date(parseInt(packet.slice(offset, offset + 8).toString('hex'), 16));\n    offset += 8;\n\n    // Get number of objects\n    const numObjects = packet.readUInt16BE(offset);\n    offset += 2;\n\n    // Decode objects\n    const objects = [];\n    for (let i = 0; i < numObjects && offset < packet.length - FOOTER.length; i++) {\n        try {\n            const object = {\n                lane: packet[offset + 1],\n                targetType: packet[offset + 2],\n                length: packet[offset + 3] / 10, // Convert to meters\n                width: packet[offset + 4] / 10,  // Convert to meters\n                height: packet[offset + 5] / 10, // Convert to meters\n                xCoord: packet.readInt16BE(offset + 8) / 100, // Convert to meters\n                yCoord: packet.readUInt16BE(offset + 10) / 100,\n                speed: packet.readInt16BE(offset + 12) / 100, // Convert to m/s\n                direction: packet.readUInt16BE(offset + 14) / 10, // Convert to degrees\n            };\n            objects.push(object);\n            offset += 36; // Each object is 36 bytes according to protocol\n        } catch (e) {\n            node.warn(\"Error decoding object: \" + e.message);\n            break;\n        }\n    }\n\n    return {\n        type,\n        deviceId,\n        timestamp,\n        numObjects,\n        objects\n    };\n}\n\nlet radarContext = global.get(\"radarContext\") || {};\nconst packet = Buffer.from(msg.payload);\n\n// Validate basic packet structure\nif (!validatePacket(packet)) {\n    node.warn(\"Invalid packet structure!\");\n    return null;\n}\n\nconst typeByte = packet[HEADER.length];\n\nif (typeByte === 0x05) {\n    // Store last detection event in global memory\n    radarContext.lastDetection = packet.toString('hex').toUpperCase();\n    global.set(\"radarContext\", radarContext);\n    return null;  // Do not send yet, wait for 0x01\n}\n\nif (typeByte === 0x01 && radarContext.lastDetection) {\n    let classificationData = packet.toString('hex').toUpperCase();\n    let decodedData = null;\n\n    try {\n        decodedData = decodeClassificationData(packet);\n    } catch (e) {\n        node.warn(\"Error decoding classification data: \" + e.message);\n    }\n\n    msg.payload = {\n        counting: radarContext.lastDetection,\n        classification: classificationData,\n        decodedData: decodedData,\n        isValid: {\n            counting: validatePacket(Buffer.from(radarContext.lastDetection, 'hex')),\n            classification: validatePacket(packet)\n        }\n    };\n\n    // Clear stored detection after processing\n    radarContext.lastDetection = null;\n    global.set(\"radarContext\", radarContext);\n\n    return msg;\n}\n\nreturn null;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":620,"y":240,"wires":[["1bb27184cdb8a5ac"]]},{"id":"1bb27184cdb8a5ac","type":"debug","z":"b2e8ff8ae08e43af","name":"debug 3","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":780,"y":200,"wires":[]},{"id":"30ec0f17a33b7d0e","type":"function","z":"b2e8ff8ae08e43af","d":true,"name":"0x01","func":"const HEADER = Buffer.from([0x55, 0xAA, 0x55, 0xBB]);\nconst packet = Buffer.from(msg.payload);\nconst typeByte = packet[HEADER.length];\n\nif (typeByte === 0x01) {\n    msg.payload = packet.toString('hex').toUpperCase();\n    return msg;\n}\nreturn null;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":570,"y":360,"wires":[["681afdf16f2fb5c4"]]},{"id":"681afdf16f2fb5c4","type":"debug","z":"b2e8ff8ae08e43af","name":"debug 4","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":750,"y":340,"wires":[]},{"id":"ce45a8b9181f1c78","type":"function","z":"b2e8ff8ae08e43af","d":true,"name":"function 4","func":"// --- Global cache reset logic ---\n// We reset the cache every 5 minutes to avoid stale data.\nlet resetIntervalMs = 5 * 60 * 1000;\nlet lastResetTime = global.get(\"lastResetTime\") || 0;\nlet currentTime = Date.now();\nif (currentTime - lastResetTime >= resetIntervalMs) {\n    global.set(\"latestObjectData\", {}); // Clear the cache\n    global.set(\"lastResetTime\", currentTime);\n    node.warn(\"Global object data cache reset.\");\n}\n\n// Ensure payload exists and is a nonempty hex string\nif (!msg.payload || typeof msg.payload !== \"string\" || msg.payload.length < 76) {\n    msg.payload = { error: \"Invalid or too short payload data\" };\n    return msg;\n}\n\nlet hexString = msg.payload;\n\n// --- Common Header Parsing ---\n// According to the protocol, the hex string contains:\n//  Header (4 bytes = 8 hex chars)\n//  Frame Type (1 byte = 2 hex chars)  at positions 8-10\n//  Checksum (1 byte = 2 hex chars)  positions 10-12\n//  Reserved (2 bytes = 4 hex chars)  skipped (positions 12-16)\n//  Device ID (20 bytes = 40 hex chars)  positions 16-56\n//  Data Timestamp (8 bytes = 16 hex chars)  positions 56-72\n//  Number of Targets/Entries (2 bytes = 4 hex chars)  positions 72-76\nlet frameType = parseInt(hexString.substring(8, 10), 16);\n\nif (frameType === 0x01) {\n    // --- Process ObjectData (0x01) Packet ---\n    let header = {\n        frameType: frameType,\n        checksum: parseInt(hexString.substring(10, 12), 16),\n        deviceId: hexString.substring(16, 56),\n        timestamp: (function () {\n            let rawTS = parseInt(hexString.substring(56, 72), 16);\n            let d = new Date(rawTS);\n            d.setHours(d.getHours() + 8); // Adjust to UTC+8 (Malaysia Time)\n            return d.toISOString();\n        })(),\n        numberOfTargets: parseInt(hexString.substring(72, 76), 16)\n    };\n\n    // If there are no targets, ignore this message.\n    if (header.numberOfTargets === 0) return null;\n\n    // --- Parse the First Target Data (from 0x01) ---\n    // Assume the target data starts immediately after header (i.e. at hex index 76).\n    // According to your earlier function, the target data structure is:\n    //  Target ID: 10 bytes (8-byte timestamp + 2-byte cyclicId)\n    //  Lane: 1 byte (positions 76+20 to 76+22)\n    //  Target type: 1 byte (positions 76+22 to 76+24)\n    //  ... (other fields not used here)\n    let targetDataStart = 76;\n    // Parse the 10-byte Target ID:\n    let targetTimestampHex = hexString.substring(targetDataStart, targetDataStart + 16);\n    let cyclicId = parseInt(hexString.substring(targetDataStart + 16, targetDataStart + 20), 16);\n    let targetDate = new Date(parseInt(targetTimestampHex, 16));\n    targetDate.setHours(targetDate.getHours() + 8);\n    let targetId = {\n        timestamp: targetDate.toISOString(),\n        cyclicId: cyclicId\n    };\n\n    // Parse lane (1 byte):\n    let lane = parseInt(hexString.substring(targetDataStart + 20, targetDataStart + 22), 16);\n\n    // Parse target type (car classification) (1 byte):\n    let typeVal = parseInt(hexString.substring(targetDataStart + 22, targetDataStart + 24), 16);\n    let typeMap = {\n        0x00: \"other\",\n        0x01: \"C6\",\n        0x02: \"C6\",\n        0x03: \"tricycle\",\n        0x04: \"C5\",\n        0x05: \"C3\",\n        0x06: \"C1\",\n        0x07: \"C2\",\n        0x08: \"C4\",\n        0x09: \"C4\",\n        0x0A: \"C3\",\n        0x0B: \"C4\",\n        0x0C: \"C4\",\n        0x0D: \"person\",\n        0x0E: \"C5\"\n    };\n    let vehicleClass = typeMap[typeVal] || \"unknown\";\n\n    // Build the target object (you can add more fields as needed)\n    let target = {\n        targetId: targetId,\n        lane: lane,\n        class: vehicleClass\n    };\n\n    // Store the decoded 0x01 data into the global cache keyed by lane number.\n    let objectCache = global.get(\"latestObjectData\") || {};\n    objectCache[lane] = { header: header, target: target };\n    global.set(\"latestObjectData\", objectCache);\n\n    // Do not output anything yet when receiving 0x01.\n    return null;\n\n} else if (frameType === 0x05) {\n    // --- Process PassData (0x05) Packet ---\n    // For PassData, we are interested in the speed.\n    // First, convert the hex string to a Buffer.\n    let buf = Buffer.from(hexString, \"hex\");\n    // In PassData the header is the same (76 hex chars = 38 bytes).\n    // According to the documentation for 0x05:\n    //  Lane No. is 2 bytes starting at the beginning of target data (i.e. at byte offset 38).\n    //  Then after 2 bytes for lane and 2 bytes for cross-section distance, the speed is in the next 2 bytes.\n    // Thus the speed field is at byte offset: 38 (header) + 2 (lane) + 2 (cross-section) = 42.\n    let speed = buf.readUInt16BE(42) / 10;  // Apply resolution factor (0.1)\n    let speeds = parseInt(speed);\n\n    // Only process if the speed is above 20.\n    if (speeds > 20) {\n        // Also extract lane from 0x05 to identify which 0x01 data to pair with.\n        // Lane is the first 2 bytes of target data in the pass packet:\n        // The header length in hex is 76 characters  38 bytes.\n        // So lane is at hex positions 76 to 80.\n        let passLane = parseInt(hexString.substring(76, 80), 16);\n\n        // Look up the corresponding ObjectData (0x01) from the global cache.\n        let objectCache = global.get(\"latestObjectData\") || {};\n        if (objectCache[passLane]) {\n            // Combine the header/target from 0x01 with the speed from 0x05.\n            let output = {\n                header: objectCache[passLane].header,\n                target: objectCache[passLane].target,\n                passSpeed: speeds\n            };\n            // Remove the entry so it is counted only once.\n            delete objectCache[passLane];\n            global.set(\"latestObjectData\", objectCache);\n            msg.payload = output;\n            return msg;\n        } else {\n            // No matching 0x01 data found for this lane; ignore.\n            return null;\n        }\n    } else {\n        // Speed below threshold, ignore.\n        return null;\n    }\n} else {\n    // For other frame types, do nothing.\n    return null;\n}\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":540,"y":440,"wires":[["0d06e1a69ae4f025"]]},{"id":"0d06e1a69ae4f025","type":"debug","z":"b2e8ff8ae08e43af","name":"debug 8","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":670,"y":440,"wires":[]},{"id":"6452391a85ad1367","type":"inject","z":"b2e8ff8ae08e43af","name":"Disconnect","props":[{"p":"action","v":"close","vt":"str"},{"p":"host","v":"192.168.12.11","vt":"str"},{"p":"port","v":"8998","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":180,"y":260,"wires":[["294b1fd02f433f5d"]]},{"id":"18b21440fac43576","type":"function","z":"b2e8ff8ae08e43af","name":"1","func":"/**\n * Function Node 1: Process ObjectData (0x01)\n * Input: msg.payload is a Buffer (raw TCP data).\n * Action:\n *   1. Convert to hex, verify frameType = 0x01.\n *   2. Decode the full header + first target classification.\n *   3. Append to an array in flow context: objectDataBuffer[].\n *   4. Prune stale entries (older than a few seconds).\n */\n\n// 1) Convert incoming payload to Buffer if not already, then to hex string\nif (!Buffer.isBuffer(msg.payload)) {\n    msg.payload = Buffer.from(msg.payload);\n}\nlet hexString = msg.payload.toString('hex');\n\n// 2) Basic length check for header + one target\nif (hexString.length < 76) {\n    node.warn(\"0x01: Payload too short\");\n    return null;\n}\n\n// 3) Verify frame type = 0x01\nlet frameType = parseInt(hexString.substring(8, 10), 16);\nif (frameType !== 0x01) return null;\n\n// 4) Decode header\nlet checksum = parseInt(hexString.substring(10, 12), 16);\nlet deviceId = hexString.substring(16, 56); // 20 bytes = 40 hex chars\nlet rawTS = parseInt(hexString.substring(56, 72), 16); // data timestamp (8 bytes)\nlet d = new Date(rawTS);\nd.setHours(d.getHours() + 8); // Example: UTC+8 offset\nlet isoTimestamp = d.toISOString();\nlet numberOfTargets = parseInt(hexString.substring(72, 76), 16);\nif (numberOfTargets === 0) return null;\n\n// We'll store the raw numeric timestamp for time matching.\nlet headerTimestamp = rawTS;\n\n// Build the \"header\" object exactly as you want it in the final output\nlet header = {\n    frameType: frameType,\n    checksum: checksum,\n    deviceId: deviceId,\n    timestamp: isoTimestamp,\n    numberOfTargets: numberOfTargets\n};\n\n// 5) Decode first target's classification\n// Target data starts at hex index 76\n// We skip the first 20 hex chars (10 bytes) for targetId, then lane (1 byte), type (1 byte).\nlet targetDataStart = 76;\nlet lane = parseInt(hexString.substring(targetDataStart + 20, targetDataStart + 22), 16);\nlet typeVal = parseInt(hexString.substring(targetDataStart + 22, targetDataStart + 24), 16);\n\nlet typeMap = {\n    0x00: \"other\",\n    0x01: \"C6\",\n    0x02: \"C6\",\n    0x03: \"tricycle\",\n    0x04: \"C5\",\n    0x05: \"C3\",\n    0x06: \"C1\",\n    0x07: \"C2\",\n    0x08: \"C4\",\n    0x09: \"C4\",\n    0x0A: \"C3\",\n    0x0B: \"C4\",\n    0x0C: \"C4\",\n    0x0D: \"person\",\n    0x0E: \"C5\"\n};\nlet vehicleClass = typeMap[typeVal] || \"unknown\";\n\n// Build the object we'll store in the buffer\nlet objectData = {\n    headerTimestamp: headerTimestamp, // numeric ms for matching\n    arrivalTime: Date.now(),         // local arrival time\n    header: header,                  // full header as needed\n    lane: lane,\n    class: vehicleClass\n};\n\n// 6) Append to buffer in flow context\nlet buffer = flow.get(\"objectDataBuffer\") || [];\nbuffer.push(objectData);\n\n// 7) Prune old entries (e.g. keep only last 5 seconds)\nlet now = Date.now();\nlet fiveSecondsAgo = now - 5000;\nbuffer = buffer.filter(item => item.arrivalTime >= fiveSecondsAgo);\n\n// 8) Store updated buffer\nflow.set(\"objectDataBuffer\", buffer);\n\n// 9) Do not output anything\nreturn null;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":670,"y":140,"wires":[["fb6caf5dcc6e4615"]]},{"id":"4b7a9bd5613d5cdb","type":"function","z":"b2e8ff8ae08e43af","name":"2","func":"/**\n * Function Node 2: Process PassData (0x05)\n * Input: msg.payload is a Buffer (raw TCP data).\n * Action:\n *   1. Convert to hex, verify frameType = 0x05.\n *   2. Extract pass event info (timestamp, speed).\n *   3. Only output a message with pass data if speed > 20.\n */\n\n// Ensure msg.payload is a Buffer and convert to hex string\nif (!Buffer.isBuffer(msg.payload)) {\n    msg.payload = Buffer.from(msg.payload);\n}\nlet hexString = msg.payload.toString('hex');\nif (hexString.length < 76) {\n    node.warn(\"0x05: Payload too short\");\n    return null;\n}\n\n// Check frame type (should be 0x05)\nlet frameType = parseInt(hexString.substring(8, 10), 16);\nif (frameType !== 0x05) return null;\n\n// Extract pass data timestamp from positions 5672 (8 bytes)\nlet rawTS = parseInt(hexString.substring(56, 72), 16);\nlet passDate = new Date(rawTS);\npassDate.setHours(passDate.getHours() + 8);\nlet isoTimestamp = passDate.toISOString();\n\n// Use Buffer to read speed at offset 38 + 4 = 42 (2 bytes), resolution factor 0.1\nlet headerLen = 38;\nlet speedVal = msg.payload.readUInt16BE(headerLen + 4) / 10;\nlet passSpeed = parseInt(speedVal);\n\n// Only proceed if passSpeed > 20; otherwise, ignore this message.\nif (passSpeed <= 20) return null;\n\n// Output a message with pass data\nmsg.payload = {\n    frameType: frameType,\n    passTimestamp: rawTS,   // raw numeric timestamp in ms\n    isoTimestamp: isoTimestamp,\n    passSpeed: passSpeed,\n    arrivalTime: Date.now()\n};\n\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":650,"y":180,"wires":[["fb6caf5dcc6e4615"]]},{"id":"fb6caf5dcc6e4615","type":"function","z":"b2e8ff8ae08e43af","name":"3","func":"/**\n * Function Node 3: Aggregator\n * Input: msg.payload from Node 2 (PassData).\n *   { frameType, passTimestamp, isoTimestamp, passSpeed, arrivalTime }\n * Action:\n *   1. Retrieve objectDataBuffer from flow.\n *   2. Find the 0x01 entry with the smallest time difference from passTimestamp (within threshold).\n *   3. Produce final JSON object:\n *       {\n *         \"header\": {\n *           \"frameType\": ...,\n *           \"checksum\": ...,\n *           \"deviceId\": \"...\",\n *           \"timestamp\": \"...\",\n *           \"numberOfTargets\": ...\n *         },\n *         \"target\": {\n *           \"lane\": ...,\n *           \"class\": \"...\",\n *           \"speed\": ...\n *         }\n *       }\n */\n\nlet passData = msg.payload;\nif (!passData || typeof passData.passTimestamp === 'undefined') {\n    node.warn(\"No pass event in payload\");\n    return null;\n}\n\nlet buffer = flow.get(\"objectDataBuffer\") || [];\nif (buffer.length === 0) {\n    node.warn(\"No 0x01 data available\");\n    return null;\n}\n\n// Find best match by timestamp difference\nlet bestMatch = null;\nlet bestDiff = Infinity;\nlet thresholdMs = 1000; // 1 seconds, adjust as needed\n\nfor (let i = 0; i < buffer.length; i++) {\n    let obj = buffer[i];\n    let diff = Math.abs(obj.headerTimestamp - passData.passTimestamp);\n    if (diff < bestDiff) {\n        bestDiff = diff;\n        bestMatch = obj;\n    }\n}\n\n// If best match is within threshold, combine data\nif (bestMatch && bestDiff <= thresholdMs) {\n    // bestMatch.header = { frameType, checksum, deviceId, timestamp, numberOfTargets }\n    // bestMatch.lane, bestMatch.class\n    // passData.passSpeed => \"speed\" in final \"target\"\n\n    let output = {\n        header: bestMatch.header,  // same structure as we stored\n        target: {\n            lane: bestMatch.lane,\n            class: bestMatch.class,\n            speed: passData.passSpeed\n        }\n    };\n\n    msg.payload = output;\n    return msg;\n} else {\n    node.warn(\"No 0x01 found within \" + thresholdMs + \" ms of 0x05 event\");\n    return null;\n}\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":870,"y":140,"wires":[["5716cab62ba46694"]]},{"id":"5716cab62ba46694","type":"debug","z":"b2e8ff8ae08e43af","name":"debug 17","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":900,"y":260,"wires":[]},{"id":"294b1fd02f433f5d","type":"tcp-client","z":"b2e8ff8ae08e43af","d":true,"action":"action","actionType":"msg","host":"host","hostType":"msg","port":"port","portType":"msg","datamode":"stream","datatype":"buffer","newline":"","write":"payload","writeType":"msg","maxRetries":"5","retryDelay":"3000","indefiniteRetries":false,"topic":"","name":"","debug":"warning","x":380,"y":180,"wires":[["3f2b64ebe128ebe3","1ef22963dcff4f36","30ec0f17a33b7d0e","ce45a8b9181f1c78","18b21440fac43576","4b7a9bd5613d5cdb"]]},{"id":"34af04022357551e","type":"function","z":"b2e8ff8ae08e43af","name":"function 6","func":"// Check if payload exists and is valid\nif (msg.payload) {\n    let hexString = msg.payload;\n\n    // if (typeof hexString === \"string\" && hexString.length >= 76) {\n        try {\n            // Extract first target data section (starting at byte 39)\n            //let speed = (parseInt(hexString.substring(43, 44), 16) / 10);\n            let speed = hexString.readUInt16BE(42) / 10;\n            let speeds = parseInt(speed);\n            //  msg.payload = speed / 10;\n            // Only send the speed if it's 20 or above\n            if (speeds > 20) {\n                let numStr = speeds.toString();\n\n                // Convert each digit to its ASCII value (in hex)\n                let hexDigits = numStr.split('').map(digit => digit.charCodeAt(0).toString(16).toUpperCase());\n\n                // Combine into a buffer if needed\n                msg.payload = Buffer.from(hexDigits.map(d => parseInt(d, 16)));\n                //msg.payload = parseInt(speed);\n            } else {\n                //let number = 20;\n                //let numStr = number.toString();// or you can return nothing to ignore the message\n                                // Convert each digit to its ASCII value (in hex)\n                //let hexDigits = numStr.split('').map(digit => digit.charCodeAt(0).toString(16).toUpperCase());\n\n                // Combine into a buffer if needed\n                //msg.payload = Buffer.from(hexDigits.map(d => parseInt(d, 16)));\n            }\n\n        } catch (error) {\n            msg.payload = { \n                error: \"Error parsing data: \" + error.message,\n                details: \"Error occurred while processing the hex string\"\n            };\n        }\n    // } else {\n    //     //msg.payload = { error: \"Invalid or too short payload data\" };\n    // }\n} else {\n    //msg.payload = { error: \"Payload not found\" };\n}\n\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":280,"y":620,"wires":[["7a2d30ec44bb71fc"]]},{"id":"7a2d30ec44bb71fc","type":"debug","z":"b2e8ff8ae08e43af","name":"debug 19","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":520,"y":580,"wires":[]},{"id":"d1a36f1f5ee74208","type":"inject","z":"b2e8ff8ae08e43af","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"55AA55BB05CD000074657374000000000000000000000000000000000000019348D43A5E0001000C0154031800000000019348D43A5E00000000000055CC55DD","payloadType":"str","x":70,"y":520,"wires":[["34af04022357551e"]]}]